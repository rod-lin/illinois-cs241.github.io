<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Pthreads, Part 3: Parallel Problems (Bonus)</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-03-15 14:21:15 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-03-15 14:21:15 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Pthreads, Part 3: Parallel Problems (Bonus)
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//Pthreads,-Part-3:-Parallel-Problems-(Bonus)">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_embarrassingly-parallel-problems" href="#embarrassingly-parallel-problems" class="fancy-link">Embarrassingly Parallel Problems</a></li>
<li><a id="toc_worker-pool" href="#worker-pool" class="fancy-link">Worker Pool</a></li>
<li><a id="toc_another-problem-parallel-map" href="#another-problem-parallel-map" class="fancy-link">Another problem, Parallel Map</a></li>
<li><a id="toc_scheduling" href="#scheduling" class="fancy-link">Scheduling</a></li>
<li><a id="toc_few-drawbacks" href="#few-drawbacks" class="fancy-link">Few Drawbacks</a></li>
<li><a id="toc_other-problems" href="#other-problems" class="fancy-link">Other Problems</a></li>
</ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper"><div class="pad"><div class="card">





<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="overview">Overview</h1>
<p>The next section deals with what happens when pthreads collide, but what if we have each thread do something entirely different, no overlap?</p>
<p>We have found the maximum speedup parallel problems?</p>
<div class="pad"><div class="card">
<div class="title"><h2 id="embarrassingly-parallel-problems" class="title-text">Embarrassingly Parallel Problems<a class="anchor title-text" href="#embarrassingly-parallel-problems">#</a>
</h2></div>

<p>The study of parallel algorithms has exploded over the past few years. An embarrassingly parallel problem is any problem that needs little effort to turn parallel. A lot of them have some synchronization concepts with them but not always. You already know a parallelizable algorithm, Merge Sort!</p>

<pre><code class="language-C"><a class="code-copy" rel="code-copy-0" onclick="onCopy(this);">Copy</a><span class="kt">void</span> <span class="n">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">){</span>
     <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
     <span class="c1">//Mergesort the left half</span>
     <span class="c1">//Mergesort the right half</span>
     <span class="c1">//Merge the two halves</span>
     <span class="p">}</span>
<textarea id="code-copy-0" class="code-copy-textarea" value="void merge_sort(int *arr, size_t len){
     if(len &amp;gt; 1){
     //Mergesort the left half
     //Mergesort the right half
     //Merge the two halves
     }
"></textarea></code></pre>

<p>With your new understanding of threads, all you need to do is create a thread for the left half, and one for the right half. Given that your CPU has multiple real cores, you will see a speedup in accordance with <a href="https://en.wikipedia.org/wiki/Amdahl's_law" class="fancy-link wiki-link">Amdahl’s Law</a>. The time complexity analysis gets interesting here as well. The parallel algorithm runs in O(log^3(n)) running time (because we fancy analysis assuming that we have a lot of cores.</p>

<p>In practice though, we typically do two changes. One, once the array gets small enough, we ditch the parallel mergesort algorithm and do a quicksort or other algorithm that works fast on small arrays (something something cache coherency). The other thing that we know is that CPUs don’t have infinite cores. To get around that, we typically keep a worker pool.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="worker-pool" class="title-text">Worker Pool<a class="anchor title-text" href="#worker-pool">#</a>
</h2></div>

<p>We know that CPUs have a finite amount of cores. A lot of times we start up a number of threads and give them tasks as they idle.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="another-problem-parallel-map" class="title-text">Another problem, Parallel Map<a class="anchor title-text" href="#another-problem-parallel-map">#</a>
</h2></div>

<p>Say we want to apply a function to an entire array, one element at a time.</p>

<pre><code class="language-C"><a class="code-copy" rel="code-copy-1" onclick="onCopy(this);">Copy</a>
<span class="kt">int</span> <span class="o">*</span><span class="n">map</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
        <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-1" class="code-copy-textarea" value="
int *map(int (*func)(int), int *arr, size_t len){
    int *ret = malloc(len*sizeof(*arr));
    for(size_t i = 0; i &amp;lt; len; ++i) 
        ret[i] = func(arr[i]);
    return ret;
}
"></textarea></code></pre>

<p>Since none of the elements depend on any other element, how would you go about parallelizing this? What do you think would be the best way to split up the work between threads.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="scheduling" class="title-text">Scheduling<a class="anchor title-text" href="#scheduling">#</a>
</h2></div>

<p>There are a few ways to split up the work.</p>
<ul>
  <li>static scheduling: break up the problems into fixed size chunks (predetermined) and have each thread work on each of the chunks. This works well when each of the subproblems take roughly the same time because there is no additional overhead. All you need to do is write a loop and give the map function to each subarray.</li>
  <li>dynamic scheduling: as a new problem becomes available have a thread serve it. This is useful when you don’t know how long the scheduling will take</li>
  <li>guided scheduling: This is a mix of the above with a mix of the benefits and the tradeoffs. You start with a static scheduling and move slowly to dynamic if needed</li>
  <li>runtime scheduling: You have absolutely no idea how long the problems are going to take. Instead of deciding it yourself, let the program decide what to do!</li>
</ul>

<p><a href="https://software.intel.com/en-us/articles/openmp-loop-scheduling" class="fancy-link wiki-link">source</a>, but no need to memorize.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="few-drawbacks" class="title-text">Few Drawbacks<a class="anchor title-text" href="#few-drawbacks">#</a>
</h2></div>

<p>You won’t see the speedup right away because of things like cache coherency and scheduling extra threads.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="other-problems" class="title-text">Other Problems<a class="anchor title-text" href="#other-problems">#</a>
</h2></div>

<p>From <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" class="fancy-link wiki-link">Wikipedia</a></p>
<ul>
  <li>Serving static files on a webserver to multiple users at once.</li>
  <li>The Mandelbrot set, Perlin noise and similar images, where each point is calculated independently.</li>
  <li>Rendering of computer graphics. In computer animation, each frame may be rendered independently (see parallel rendering).</li>
  <li>Brute-force searches in cryptography.[8] Notable real-world examples include distributed.net and proof-of-work systems used in cryptocurrency.</li>
  <li>BLAST searches in bioinformatics for multiple queries (but not for individual large queries) [9]</li>
  <li>Large scale facial recognition systems that compare thousands of arbitrary acquired faces (e.g., a security or surveillance video via closed-circuit television) with similarly large number of previously stored faces (e.g., a rogues gallery or similar watch list).[10]</li>
  <li>Computer simulations comparing many independent scenarios, such as climate models.</li>
  <li>Evolutionary computation metaheuristics such as genetic algorithms.</li>
  <li>Ensemble calculations of numerical weather prediction.</li>
  <li>Event simulation and reconstruction in particle physics.</li>
  <li>The marching squares algorithm</li>
  <li>Sieving step of the quadratic sieve and the number field sieve.</li>
  <li>Tree growth step of the random forest machine learning technique.</li>
  <li>Discrete Fourier Transform where each harmonic is independently calculated.</li>
</ul>
</div></div>
</div></div></div>
</div></div></div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/pthreads-part-3-parallel-problems-(bonus).md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-Ra6zh6uYMmH5ydwCqqMoykyf1T/+ZcnOQfFPhDrp2kI4OIxadnhsvvA2vv9A7xYv" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-03-15 14:21:15 +0000"></script>

<script>
$(document).ready(function(){
    $('[data-toggle="popover"]').popover({
      trigger: 'manual',
        container: $(this).attr('id'),
        placement: 'top',
        content: function () {
            return '<div class="hover-hovercard"></div>';
        }
    }).on("mouseenter", function () {
        var _this = this;
        $(this).popover("show");
        $(this).siblings(".popover").on("mouseleave", function () {
            $(_this).popover('hide');
        });
    }).on("mouseleave", function () {
        var _this = this;
        setTimeout(function () {
            if (!$(".popover:hover").length) {
               $(_this).popover("hide")
            }
        }, 100);
    });

    $('[data-toggle="tooltip"]').tooltip();
});

</script>
<script src="/js/analytics.js"></script>
<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
