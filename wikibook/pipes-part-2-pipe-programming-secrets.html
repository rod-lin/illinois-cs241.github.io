<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Pipes, Part 2: Pipe programming secrets</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-09-08 16:51:38 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-09-08 16:51:38 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Pipes, Part 2: Pipe programming secrets
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//Pipes,-Part-2:-Pipe-programming-secrets">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_want-to-use-pipes-with-printf-and-scanf-use-fdopen" href="#want-to-use-pipes-with-printf-and-scanf-use-fdopen" class="fancy-link">Want to use pipes with printf and scanf? Use fdopen!</a></li>
<li><a id="toc_so-do-we-need-to-fflush-too" href="#so-do-we-need-to-fflush-too" class="fancy-link">So do we need to <code class="highlighter-rouge">fflush</code> too?</a></li>
<li><a id="toc_when-do-i-need-two-pipes" href="#when-do-i-need-two-pipes" class="fancy-link">When do I need two pipes?</a></li>
<li><a id="toc_closing-pipes-gotchas" href="#closing-pipes-gotchas" class="fancy-link">Closing pipes gotchas</a></li>
<li><a id="toc_what-is-filling-up-the-pipe-what-happens-when-the-pipe-becomes-full" href="#what-is-filling-up-the-pipe-what-happens-when-the-pipe-becomes-full" class="fancy-link">What is filling up the pipe? What happens when the pipe becomes full?</a></li>
<li><a id="toc_are-pipes-process-safe" href="#are-pipes-process-safe" class="fancy-link">Are pipes process safe?</a></li>
<li><a id="toc_the-lifetime-of-pipes" href="#the-lifetime-of-pipes" class="fancy-link">The lifetime of pipes</a></li>
<li><a id="toc_how-do-i-create-named-pipes" href="#how-do-i-create-named-pipes" class="fancy-link">How do I create named pipes?</a></li>
<li><a id="toc_why-is-my-pipe-hanging" href="#why-is-my-pipe-hanging" class="fancy-link">Why is my pipe hanging?</a></li>
<li><a id="toc_race-condition-with-named-pipes" href="#race-condition-with-named-pipes" class="fancy-link">Race condition with named pipes.</a></li>
</ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper">
<div class="pad"><div class="card">









<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="pipe-gotchas">Pipe Gotchas</h1>
<p>Here’s a complete example that doesn’t work! The child reads one byte at a time from the pipe and prints it out - but we never see the message! Can you see why?</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-0" onclick="onCopy(this);">Copy</a><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="c1">// You must read from fd[0] and write from fd[1]</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Reading from %d, writing to %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">pid_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* I have a child therefore I am the parent*/</span>
        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"Hi Child!"</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>

        <span class="cm">/*don't forget your child*/</span>
        <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">bytesread</span><span class="p">;</span>
        <span class="c1">// read one byte at a time.</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<textarea id="code-copy-0" class="code-copy-textarea" value="#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

int main() {
    int fd[2];
    pipe(fd);
    // You must read from fd[0] and write from fd[1]
    printf(&quot;Reading from %d, writing to %d\n&quot;, fd[0], fd[1]);

    pid_t p = fork();
    if (p &amp;gt; 0) {
        /* I have a child therefore I am the parent*/
        write(fd[1],&quot;Hi Child!&quot;,9);

        /*don't forget your child*/
        wait(NULL);
    } else {
        char buf;
        int bytesread;
        // read one byte at a time.
        while ((bytesread = read(fd[0], &amp;amp;buf, 1)) &amp;gt; 0) {
            putchar(buf);
        }
    }
    return 0;
}

"></textarea></code></pre>
<p>The parent sends the bytes <code class="highlighter-rouge">H,i,(space),C...!</code> into the pipe (this may block if the pipe is full).
The child starts reading the pipe one byte at a time. In the above case, the child process will read and print each character. However it never leaves the while loop! When there are no characters left to read it simply blocks and waits for more.</p>
<p>The call <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/putchar" class="fancy-link">putchar</a></code> writes the characters out but we never flush the <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/stdout" class="fancy-link">stdout</a></code> buffer. i.e. We have transferred the message from one process to another but it has not yet been printed. To see the message we could flush the buffer e.g. <code class="highlighter-rouge">fflush(stdout)</code> (or <code class="highlighter-rouge">printf("\n")</code> if the output is going to a terminal). A better solution would also exit the loop by checking for an end-of-message marker,</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-1" onclick="onCopy(this);">Copy</a>        <span class="k">while</span> <span class="p">((</span><span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">'!'</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* End of message */</span>
        <span class="p">}</span>
<textarea id="code-copy-1" class="code-copy-textarea" value="        while ((bytesread = read(fd[0], &amp;amp;buf, 1)) &amp;gt; 0) {
            putchar(buf);
            if (buf == '!') break; /* End of message */
        }
"></textarea></code></pre>
<p>And the message will be flushed to the terminal when the child process exits.</p>
<div class="pad"><div class="card">
<div class="title"><h2 id="want-to-use-pipes-with-printf-and-scanf-use-fdopen" class="title-text">Want to use pipes with printf and scanf? Use fdopen!<a class="anchor title-text" href="#want-to-use-pipes-with-printf-and-scanf-use-fdopen">#</a>
</h2></div>

<p>POSIX file descriptors are simple integers 0,1,2,3…
At the C library level, C wraps these with a buffer and useful functions like printf and scanf, so we that we can easily print or parse integers, strings etc.
If you already have a file descriptor then you can ‘wrap’ it yourself into a FILE pointer using <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fdopen" class="fancy-link">fdopen</a></code> :</p>

<pre><code class="language-C"><a class="code-copy" rel="code-copy-2" onclick="onCopy(this);">Copy</a><span class="cp">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">"Fred"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">filedes</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"mydata.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUSR</span><span class="p">);</span>

    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">filedes</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Name:%s Score:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<textarea id="code-copy-2" class="code-copy-textarea" value='#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main() {
    char *name = "Fred";
    int score = 123;
    int filedes = open("mydata.txt", "w", O_CREAT, S_IWUSR | S_IRUSR);

    FILE *f = fdopen(filedes, "w");
    fprintf(f, "Name:%s Score:%d\n", name, score);
    fclose(f);
'></textarea></code></pre>
<p>For writing to files this is unnecessary - just use <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fopen" class="fancy-link">fopen</a></code> which does the same as <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code> and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fdopen" class="fancy-link">fdopen</a></code>
However for pipes, we already have a file descriptor - so this is great time to use <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fdopen" class="fancy-link">fdopen</a></code>!</p>

<p>Here’s a complete example using pipes that almost works! Can you spot the error? Hint: The parent never prints anything!</p>

<pre><code class="language-C"><a class="code-copy" rel="code-copy-3" onclick="onCopy(this);">Copy</a><span class="cp">#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">reader</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">writer</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="n">pid_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">score</span><span class="p">;</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="s">"Score %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">score</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"The child says the score is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">"Score %d"</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-3" class="code-copy-textarea" value='#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main() {
    int fh[2];
    pipe(fh);
    FILE *reader = fdopen(fh[0], "r");
    FILE *writer = fdopen(fh[1], "w");
    pid_t p = fork();
    if (p &amp;gt; 0) {
        int score;
        fscanf(reader, "Score %d", &amp;amp;score);
        printf("The child says the score is %d\n", score);
    } else {
        fprintf(writer, "Score %d", 10 + 10);
        fflush(writer);
    }
    return 0;
}
'></textarea></code></pre>
<p>Note the (unnamed) pipe resource will disappear once both the child and parent have exited. In the above example the child will send the bytes and the parent will receive the bytes from the pipe. However, no end-of-line character is ever sent, so <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fscanf" class="fancy-link">fscanf</a></code> will continue to ask for bytes because it is waiting for the end of the line i.e. it will wait forever! The fix is to ensure we send a newline character, so that <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fscanf" class="fancy-link">fscanf</a></code> will return.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-4" onclick="onCopy(this);">Copy</a><span class="nl">change:</span>   <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">"Score %d"</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">to</span><span class="o">:</span>       <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">"Score %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
<textarea id="code-copy-4" class="code-copy-textarea" value='change:   fprintf(writer, "Score %d", 10 + 10);
to:       fprintf(writer, "Score %d\n", 10 + 10);
'></textarea></code></pre>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="so-do-we-need-to-fflush-too" class="title-text">So do we need to <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fflush" class="fancy-link">fflush</a></code> too?<a class="anchor title-text" href="#so-do-we-need-to-fflush-too">#</a>
</h2></div>
<p>Yes, if you want your bytes to be sent to the pipe immediately! At the beginning of this course we assumed that file streams are always <em>line buffered</em> i.e. the C library will flush its buffer everytime you send a newline character. Actually this is only true for terminal streams - for other filestreams the C library attempts to improve performance by only flushing when it’s internal buffer is full or the file is closed.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="when-do-i-need-two-pipes" class="title-text">When do I need two pipes?<a class="anchor title-text" href="#when-do-i-need-two-pipes">#</a>
</h2></div>

<p>If you need to send data to and from a child asynchronously, then two pipes are required (one for each direction).
Otherwise the child would attempt to read its own data intended for the parent (and vice versa)!</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="closing-pipes-gotchas" class="title-text">Closing pipes gotchas<a class="anchor title-text" href="#closing-pipes-gotchas">#</a>
</h2></div>

<p>Processes receive the signal SIGPIPE when no process is listening! From the pipe(2) man page -</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If all file descriptors referring to the read end of a pipe have been closed,
 then a write(2) will cause a SIGPIPE signal to be generated for the calling process. 
</code></pre></div></div>

<p>Tip: Notice only the writer (not a reader) can use this signal.
To inform the reader that a writer is closing their end of the pipe, you could write your own special byte (e.g. 0xff) or a message ( <code class="highlighter-rouge">"Bye!"</code>)</p>

<p>Here’s an example of catching this signal that does not work! Can you see why?</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-5" onclick="onCopy(this);">Copy</a><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
</span>
<span class="kt">void</span> <span class="nf">no_one_listening</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"No one is listening!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">no_one_listening</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    
    <span class="n">pipe</span><span class="p">(</span><span class="n">filedes</span><span class="p">);</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
        <span class="cm">/* I must be the parent. Close the listening end of the pipe */</span>
        <span class="cm">/* I'm not listening anymore!*/</span>
        <span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Child writes messages to the pipe */</span>
        <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"One"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="c1">// Will this write generate SIGPIPE ?</span>
        <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"Two"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-5" class="code-copy-textarea" value="#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

void no_one_listening(int signal) {
    write(1, &quot;No one is listening!\n&quot;, 21);
}

int main() {
    signal(SIGPIPE, no_one_listening);
    int filedes[2];
    
    pipe(filedes);
    pid_t child = fork();
    if (child &amp;gt; 0) { 
        /* I must be the parent. Close the listening end of the pipe */
        /* I'm not listening anymore!*/
        close(filedes[0]);
    } else {
        /* Child writes messages to the pipe */
        write(filedes[1], &quot;One&quot;, 3);
        sleep(2);
        // Will this write generate SIGPIPE ?
        write(filedes[1], &quot;Two&quot;, 3);
        write(1, &quot;Done\n&quot;, 5);
    }
    return 0;
}
"></textarea></code></pre>
<p>The mistake in above code is that there is still a reader for the pipe! The child still has the pipe’s first file descriptor open and remember the specification? All readers must be closed.</p>

<p>When forking, <em>It is common practice</em> to close the unnecessary (unused) end of each pipe in the child and parent process. For example the parent might close the reading end and the child might close the writing end (and vice versa if you have two pipes)</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-filling-up-the-pipe-what-happens-when-the-pipe-becomes-full" class="title-text">What is filling up the pipe? What happens when the pipe becomes full?<a class="anchor title-text" href="#what-is-filling-up-the-pipe-what-happens-when-the-pipe-becomes-full">#</a>
</h2></div>

<p>A pipe gets filled up when the writer writes too much to the pipe without the reader reading any of it. When the pipes become full, all writes fail until a read occurs. Even then, a write may partial fail if the pipe has a little bit of space left but not enough for the entire message.</p>

<p>To avoid this, usually two things are done. Either increase the size of the pipe. Or more commonly, fix your program design so that the pipe is constantly being read from.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="are-pipes-process-safe" class="title-text">Are pipes process safe?<a class="anchor title-text" href="#are-pipes-process-safe">#</a>
</h2></div>

<p>Yes! Pipe write are atomic up to the size of the pipe. Meaning that if two processes try to write to the same pipe, the kernel has internal mutexes with the pipe that it will lock, do the write, and return. The only gotcha is when the pipe is about to become full. If two processes are trying to write and the pipe can only satisfy a partial write, that pipe write is not atomic – be careful about that!</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="the-lifetime-of-pipes" class="title-text">The lifetime of pipes<a class="anchor title-text" href="#the-lifetime-of-pipes">#</a>
</h2></div>

<p>Unnamed pipes (the kind we’ve seen up to this point) live in memory (do not take up any disk space) and are a simple and efficient form of inter-process communication (IPC) that is useful for streaming data and simple messages. Once all processes have closed, the pipe resources are freed.</p>

<p>An alternative to <em>unamed</em> pipes is <em>named</em> pipes created using <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mkfifo" class="fancy-link">mkfifo</a></code>.</p>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">

<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="named-pipes">Named Pipes</h1>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-do-i-create-named-pipes" class="title-text">How do I create named pipes?<a class="anchor title-text" href="#how-do-i-create-named-pipes">#</a>
</h2></div>

<p>From the command line: <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mkfifo" class="fancy-link">mkfifo</a></code>
From C: <code class="highlighter-rouge">int mkfifo(const char *pathname, mode_t mode);</code></p>

<p>You give it the path name and the operation mode, it will be ready to go! Named pipes take up no space on the disk. What the operating system is essentially telling you when you have a named pipe is that it will create an unnamed pipe that refers to the named pipe, and that’s it! There is no additional magic. This is just for programming convenience if processes are started without forking (meaning that there would be no way to get the file descriptor to the child process for an unnamed pipe)</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="why-is-my-pipe-hanging" class="title-text">Why is my pipe hanging?<a class="anchor title-text" href="#why-is-my-pipe-hanging">#</a>
</h2></div>
<p>Reads and writes hang on Named Pipes until there is at least one reader and one writer, take this</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1<span class="nv">$ </span><span class="nb">mkfifo </span>fifo
1<span class="nv">$ </span><span class="nb">echo </span>Hello <span class="o">&gt;</span> fifo
<span class="c"># This will hang until I do this on another terminal or another process</span>
2<span class="nv">$ </span><span class="nb">cat </span>fifo
Hello
</code></pre></div></div>
<p>Any <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/open" class="fancy-link">open</a></code> is called on a named pipe the kernel blocks until another process calls the opposite open. Meaning, echo calls <code class="highlighter-rouge">open(.., O_WRONLY)</code> but that blocks until cat calls <code class="highlighter-rouge">open(.., O_RDONLY)</code>, then the programs are allowed to continue.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="race-condition-with-named-pipes" class="title-text">Race condition with named pipes.<a class="anchor title-text" href="#race-condition-with-named-pipes">#</a>
</h2></div>
<p>What is wrong with the following program?</p>

<pre><code class="language-C"><a class="code-copy" rel="code-copy-6" onclick="onCopy(this);">Copy</a><span class="c1">// Program 1</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">"Hello!"</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Program 2</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"fifo"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-6" class="code-copy-textarea" value="// Program 1

int main() {
    int fd = open(&quot;fifo&quot;, O_RDWR | O_TRUNC);
    write(fd, &quot;Hello!&quot;, 6);
    close(fd);
    return 0;
}

//Program 2
int main() {
    char buffer[7];
    int fd = open(&quot;fifo&quot;, O_RDONLY);
    read(fd, buffer, 6);
    buffer[6] = '\0';
    printf(&quot;%s\n&quot;, buffer);
    return 0;
}
"></textarea></code></pre>

<p>This may never print hello because of a race condition. Since you opened the pipe in the first process under both permissions, open won’t wait for a reader because you told the operating system that you are a reader! Sometimes it looks like it works because the execution of the code looks something like this.</p>

<table class="table">
  <thead>
    <tr>
      <th>Process 1</th>
      <th>Process 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>open(O_RDWR) &amp; write()</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>open(O_RDONLY) &amp; read()</td>
    </tr>
    <tr>
      <td>close() &amp; exit()</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>print() &amp; exit()</td>
    </tr>
  </tbody>
</table>

<p>Sometimes it won’t</p>

<table class="table">
  <thead>
    <tr>
      <th>Process 1</th>
      <th>Process 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>open(O_RDWR) &amp; write()</td>
      <td> </td>
    </tr>
    <tr>
      <td>close() &amp; exit()</td>
      <td>(Named pipe is destroyed)</td>
    </tr>
    <tr>
      <td>(Blocks indefinitely)</td>
      <td>open(O_RDONLY)</td>
    </tr>
  </tbody>
</table>
</div></div>
</div></div></div>
</div></div>
</div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/pipes-part-2-pipe-programming-secrets.md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-09-08 16:51:38 +0000"></script>

<script>
$(document).ready(function() { 
    $("#tuxlink").prop("href", "javascript:;").click(function() { 
        if ("WebkitAppearance" in document.documentElement.style) { 
            var style = document.createElement("style"); 
            style.setAttribute("id", "tuxstyle"); 
            style.appendChild(document.createTextNode("")); 
            document.head.appendChild(style); 
            var sheet = style.sheet;
            sheet.insertRule("::-webkit-scrollbar-thumb {border-radius: 0; background-color: white; -webkit-box-shadow: none;}", 0); 
        } 

        const hackerKey = 'hackerLocalKey';
        const hackerOff = "off";
        const hackerOn = "on";

        if (window.localStorage.getItem(hackerKey) === null) {
            window.localStorage.setItem(hackerKey, hackerOff);
        }

        $("#tuxlink").unbind('click').click(function() { 
            const hackerClass = 'hacker';
            $('html, body, header, nav, table, pre, span, :not(.card-staff) > a, p, h1, h2, h3, h4, h5, h6').toggleClass(hackerClass);
            $('ul, img, pre').toggleClass(hackerClass);
            $('.toc').toggleClass(hackerClass);
            $('.content .highlighter-rouge').toggleClass(hackerClass);
            $('.large-centered.columns').toggleClass(hackerClass);
            $('.pad').toggleClass(hackerClass);
            $('a').toggleClass(hackerClass);
            $('tbody tr:nth-child(2n+1)').toggleClass(hackerClass);
            $("#tuxlink img").toggleClass(hackerClass);

            const val = window.localStorage.getItem(hackerKey);
            if (val === hackerOff) {
                window.localStorage.setItem(hackerKey, hackerOn);
            } else {
                window.localStorage.setItem(hackerKey, hackerOff);
            }
            return false; 
        }); 
        $("#tuxlink").click();
        const stored = window.localStorage.getItem(hackerKey);
        if (stored === hackerOn) {
            console.log("Hello!")
            $("#tuxlink").click();
        } else {
            console.log("Noo");
        }

        return false; 
    }); 
    } 
    ); 
    </script>

<script src="/js/analytics.js"></script>

<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
