<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Networking, Part 7: Nonblocking I O, select(), and epoll</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-09-08 16:51:38 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-09-08 16:51:38 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Networking, Part 7: Nonblocking I O, select(), and epoll
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//Networking,-Part-7:-Nonblocking-I-O,-select(),-and-epoll">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_epoll" href="#epoll" class="fancy-link">epoll</a></li>
<li><a id="toc_interesting-blogpost-about-edge-cases-with-select" href="#interesting-blogpost-about-edge-cases-with-select" class="fancy-link">Interesting Blogpost about edge cases with select</a></li>
</ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper">
<h3 id="dont-waste-time-waiting" class="title-text">Don’t waste time waiting</h3>

<p>Normally, when you call <code class="highlighter-rouge">read()</code>, if the data is not available yet it will wait until the data is ready before the function returns.  When you’re reading data from a disk, that delay may not be long, but when you’re reading from a slow network connection it may take a long time for that data to arrive, if it ever arrives.</p>

<p>POSIX lets you set a flag on a file descriptor such that any call to <code class="highlighter-rouge">read()</code> on that file descriptor will return immediately, whether it has finished or not.  With your file descriptor in this mode, your call to <code class="highlighter-rouge">read()</code> will start
the read operation, and while it’s working you can do other useful work.  This is called “nonblocking” mode,
since the call to <code class="highlighter-rouge">read()</code> doesn’t block.</p>

<p>To set a file descriptor to be nonblocking:</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-0" onclick="onCopy(this);">Copy</a>    <span class="c1">// fd is my file descriptor</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
<textarea id="code-copy-0" class="code-copy-textarea" value="    // fd is my file descriptor
    int flags = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
"></textarea></code></pre>
<p>For a socket, you can create it in nonblocking mode by adding <code class="highlighter-rouge">SOCK_NONBLOCK</code> to the second argument to <code class="highlighter-rouge">socket()</code>:</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-1" onclick="onCopy(this);">Copy</a>    <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<textarea id="code-copy-1" class="code-copy-textarea" value="    fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
"></textarea></code></pre>
<p>When a file is in nonblocking mode and you call <code class="highlighter-rouge">read()</code>, it will return immediately with whatever bytes are available.
Say 100 bytes have arrived from the server at the other end of your socket and you call <code class="highlighter-rouge">read(fd, buf, 150)</code>.
Read will return immediately with a value of 100, meaning it read 100 of the 150 bytes you asked for.
Say you tried to read the remaining data with a call to <code class="highlighter-rouge">read(fd, buf+100, 50)</code>, but the last 50 bytes still hadn’t
arrived yet.  <code class="highlighter-rouge">read()</code> would return -1 and set the global error variable <strong>errno</strong> to either
EAGAIN or EWOULDBLOCK.  That’s the system’s way of telling you the data isn’t ready yet.</p>

<p><code class="highlighter-rouge">write()</code> also works in nonblocking mode.  Say you want to send 40,000 bytes to a remote server using a socket.
The system can only send so many bytes at a time. Common systems can send about 23,000 bytes at a time. In nonblocking mode, <code class="highlighter-rouge">write(fd, buf, 40000)</code> would return the number of bytes it was able to
send immediately, or about 23,000.  If you called <code class="highlighter-rouge">write()</code> right away again, it would return -1 and set errno to
EAGAIN or EWOULDBLOCK. That’s the system’s way of telling you it’s still busy sending the last chunk of data,
and isn’t ready to send more yet.</p>

<h3 id="how-do-i-check-when-the-io-has-finished" class="title-text">How do I check when the I/O has finished?</h3>

<p>There are a few ways.  Let’s see how to do it using <em>select</em> and <em>epoll</em>.</p>

<div class="pad"><div class="card">










<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h4 id="select">select</h4>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-2" onclick="onCopy(this);">Copy</a>    <span class="kt">int</span> <span class="n">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> 
               <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> 
               <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span>
               <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> 
               <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
<textarea id="code-copy-2" class="code-copy-textarea" value="    int select(int nfds, 
               fd_set *readfds, 
               fd_set *writefds,
               fd_set *exceptfds, 
               struct timeval *timeout);
"></textarea></code></pre>
<p>Given three sets of file descriptors, <code class="highlighter-rouge">select()</code> will wait for any of those file descriptors to become ‘ready’.</p>
<ul>
  <li>
<code class="highlighter-rouge">readfds</code> - a file descriptor in <code class="highlighter-rouge">readfds</code> is ready when there is data that can be read or EOF has been reached.</li>
  <li>
<code class="highlighter-rouge">writefds</code> - a file descriptor in <code class="highlighter-rouge">writefds</code> is ready when a call to write() will succeed.</li>
  <li>
<code class="highlighter-rouge">exceptfds</code> - system-specific, not well-defined.  Just pass NULL for this.</li>
</ul>
<p><code class="highlighter-rouge">select()</code> returns the total number of file descriptors that are ready.  If none of them become
ready during the time defined by <em>timeout</em>, it will return 0.  After <code class="highlighter-rouge">select()</code> returns, the 
caller will need to loop through the file descriptors in readfds and/or writefds to see which
ones are ready. As readfds and writefds act as both input and output parameters, when <code class="highlighter-rouge">select()</code>
indicates that there are file descriptors which are ready, it would have overwritten them to
reflect only the file descriptors which are ready. Unless it is the caller’s intention to call
<code class="highlighter-rouge">select()</code> only once, it would be a good idea to save a copy of readfds and writefds before
calling it.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-3" onclick="onCopy(this);">Copy</a>    <span class="n">fd_set</span> <span class="n">readfds</span><span class="p">,</span> <span class="n">writefds</span><span class="p">;</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writefds</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">read_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">FD_SET</span><span class="p">(</span><span class="n">my_read_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">write_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">FD_SET</span><span class="p">(</span><span class="n">my_write_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="n">timeout</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">num_ready</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">FD_SETSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">"error in select()"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"timeout</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">read_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">my_read_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">))</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"fd %d is ready for reading</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_read_fds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">write_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">my_write_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">))</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"fd %d is ready for writing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_write_fds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<textarea id="code-copy-3" class="code-copy-textarea" value='    fd_set readfds, writefds;
    FD_ZERO(&amp;amp;readfds);
    FD_ZERO(&amp;amp;writefds);
    for (int i=0; i &amp;lt; read_fd_count; i++)
      FD_SET(my_read_fds[i], &amp;amp;readfds);
    for (int i=0; i &amp;lt; write_fd_count; i++)
      FD_SET(my_write_fds[i], &amp;amp;writefds);

    struct timeval timeout;
    timeout.tv_sec = 3;
    timeout.tv_usec = 0;

    int num_ready = select(FD_SETSIZE, &amp;amp;readfds, &amp;amp;writefds, NULL, &amp;amp;timeout);

    if (num_ready &amp;lt; 0) {
      perror("error in select()");
    } else if (num_ready == 0) {
      printf("timeout\n");
    } else {
      for (int i=0; i &amp;lt; read_fd_count; i++)
        if (FD_ISSET(my_read_fds[i], &amp;amp;readfds))
          printf("fd %d is ready for reading\n", my_read_fds[i]);
      for (int i=0; i &amp;lt; write_fd_count; i++)
        if (FD_ISSET(my_write_fds[i], &amp;amp;writefds))
          printf("fd %d is ready for writing\n", my_write_fds[i]);
    }
'></textarea></code></pre>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/select.html" class="fancy-link wiki-link">For more information on select()</a></p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="epoll" class="title-text">epoll<a class="anchor title-text" href="#epoll">#</a>
</h2></div>

















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p><em>epoll</em> is not part of POSIX, but it is supported by Linux.  It is a more efficient way to wait for many
file descriptors.  It will tell you exactly which descriptors are ready. It even gives you a way to store
a small amount of data with each descriptor, like an array index or a pointer, making it easier to access
your data associated with that descriptor.</p>
<p>To use epoll, first you must create a special file descriptor with <a href="http://linux.die.net/man/2/epoll_create" class="fancy-link wiki-link">epoll_create()</a>.  You won’t read or write to this file
descriptor; you’ll just pass it to the other epoll_xxx functions and call
close() on it at the end.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-4" onclick="onCopy(this);">Copy</a>    <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<textarea id="code-copy-4" class="code-copy-textarea" value="    epfd = epoll_create(1);
"></textarea></code></pre>
<p>For each file descriptor you want to monitor with epoll, you’ll need to add it 
to the epoll data structures 
using <a href="http://linux.die.net/man/2/epoll_ctl" class="fancy-link wiki-link">epoll_ctl()</a> with the <code class="highlighter-rouge">EPOLL_CTL_ADD</code> option.  You can add any
number of file descriptors to it.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-5" onclick="onCopy(this);">Copy</a>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>  <span class="c1">// EPOLLIN==read, EPOLLOUT==write</span>
    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">mypointer</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span>
<textarea id="code-copy-5" class="code-copy-textarea" value="    struct epoll_event event;
    event.events = EPOLLOUT;  // EPOLLIN==read, EPOLLOUT==write
    event.data.ptr = mypointer;
    epoll_ctl(epfd, EPOLL_CTL_ADD, mypointer-&amp;gt;fd, &amp;amp;event)
"></textarea></code></pre>
<p>To wait for some of the file descriptors to become ready, use <a href="http://linux.die.net/man/2/epoll_wait" class="fancy-link wiki-link">epoll_wait()</a>.
The epoll_event struct that it fills out will contain the data you provided in event.data when you
added this file descriptor. This makes it easy for you to look up your own data associated
with this file descriptor.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-6" onclick="onCopy(this);">Copy</a>    <span class="kt">int</span> <span class="n">num_ready</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">timeout_milliseconds</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">MyData</span> <span class="o">*</span><span class="n">mypointer</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyData</span><span class="o">*</span><span class="p">)</span> <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"ready to write on %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
    <span class="p">}</span>
<textarea id="code-copy-6" class="code-copy-textarea" value='    int num_ready = epoll_wait(epfd, &amp;amp;event, 1, timeout_milliseconds);
    if (num_ready &amp;gt; 0) {
      MyData *mypointer = (MyData*) event.data.ptr;
      printf("ready to write on %d\n", mypointer-&amp;gt;fd);
    }
'></textarea></code></pre>
<p>Say you were waiting to write data to a file descriptor, but now you want to wait to read data from it.
Just use <code class="highlighter-rouge">epoll_ctl()</code> with the <code class="highlighter-rouge">EPOLL_CTL_MOD</code> option to change the type of operation you’re monitoring.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-7" onclick="onCopy(this);">Copy</a>    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">mypointer</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<textarea id="code-copy-7" class="code-copy-textarea" value="    event.events = EPOLLOUT;
    event.data.ptr = mypointer;
    epoll_ctl(epfd, EPOLL_CTL_MOD, mypointer-&amp;gt;fd, &amp;amp;event);
"></textarea></code></pre>
<p>To unsubscribe one file descriptor from epoll while leaving others active, use <code class="highlighter-rouge">epoll_ctl()</code> with the <code class="highlighter-rouge">EPOLL_CTL_DEL</code> option.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-8" onclick="onCopy(this);">Copy</a>    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<textarea id="code-copy-8" class="code-copy-textarea" value="    epoll_ctl(epfd, EPOLL_CTL_DEL, mypointer-&amp;gt;fd, NULL);
"></textarea></code></pre>
<p>To shut down an epoll instance, close its file descriptor.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-9" onclick="onCopy(this);">Copy</a>    <span class="n">close</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
<textarea id="code-copy-9" class="code-copy-textarea" value="    close(epfd);
"></textarea></code></pre>
<p>In addition to nonblocking <code class="highlighter-rouge">read()</code> and <code class="highlighter-rouge">write()</code>, any calls to <code class="highlighter-rouge">connect()</code> on a nonblocking socket will also be
nonblocking. To wait for the connection to complete, use <code class="highlighter-rouge">select()</code> or epoll to wait for the socket to be writable.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="interesting-blogpost-about-edge-cases-with-select" class="title-text">Interesting Blogpost about edge cases with select<a class="anchor title-text" href="#interesting-blogpost-about-edge-cases-with-select">#</a>
</h2></div>


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><p>https://idea.popcount.org/2017-01-06-select-is-fundamentally-broken/</p></div></div></div>
</div></div>
</div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/networking-part-7-nonblocking-i-o-select()-and-epoll.md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-09-08 16:51:38 +0000"></script>

<script>
$(document).ready(function() { 
    $("#tuxlink").prop("href", "javascript:;").click(function() { 
        if ("WebkitAppearance" in document.documentElement.style) { 
            var style = document.createElement("style"); 
            style.setAttribute("id", "tuxstyle"); 
            style.appendChild(document.createTextNode("")); 
            document.head.appendChild(style); 
            var sheet = style.sheet;
            sheet.insertRule("::-webkit-scrollbar-thumb {border-radius: 0; background-color: white; -webkit-box-shadow: none;}", 0); 
        } 

        const hackerKey = 'hackerLocalKey';
        const hackerOff = "off";
        const hackerOn = "on";

        if (window.localStorage.getItem(hackerKey) === null) {
            window.localStorage.setItem(hackerKey, hackerOff);
        }

        $("#tuxlink").unbind('click').click(function() { 
            const hackerClass = 'hacker';
            $('html, body, header, nav, table, pre, span, :not(.card-staff) > a, p, h1, h2, h3, h4, h5, h6').toggleClass(hackerClass);
            $('ul, img, pre').toggleClass(hackerClass);
            $('.toc').toggleClass(hackerClass);
            $('.content .highlighter-rouge').toggleClass(hackerClass);
            $('.large-centered.columns').toggleClass(hackerClass);
            $('.pad').toggleClass(hackerClass);
            $('a').toggleClass(hackerClass);
            $('tbody tr:nth-child(2n+1)').toggleClass(hackerClass);
            $("#tuxlink img").toggleClass(hackerClass);

            const val = window.localStorage.getItem(hackerKey);
            if (val === hackerOff) {
                window.localStorage.setItem(hackerKey, hackerOn);
            } else {
                window.localStorage.setItem(hackerKey, hackerOff);
            }
            return false; 
        }); 
        $("#tuxlink").click();
        const stored = window.localStorage.getItem(hackerKey);
        if (stored === hackerOn) {
            console.log("Hello!")
            $("#tuxlink").click();
        } else {
            console.log("Noo");
        }

        return false; 
    }); 
    } 
    ); 
    </script>

<script src="/js/analytics.js"></script>

<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
