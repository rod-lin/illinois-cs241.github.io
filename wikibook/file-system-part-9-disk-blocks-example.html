<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>File System, Part 9: Disk blocks example</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-03-15 14:21:15 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-03-15 14:21:15 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              File System, Part 9: Disk blocks example
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//File-System,-Part-9:-Disk-blocks-example">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_under-construction" href="#under-construction" class="fancy-link">Under construction</a></li>
<li><a id="toc_please-can-you-explain-a-simple-model-of-how-the-files-content-is-stored-in-a-simple-i-node-based-filesystem" href="#please-can-you-explain-a-simple-model-of-how-the-files-content-is-stored-in-a-simple-i-node-based-filesystem" class="fancy-link">Please can you explain a simple model of how the file’s content is stored in a simple i-node based filesystem?</a></li>
</ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper">
<div class="pad"><div class="card">
<div class="title"><h2 id="under-construction" class="title-text">Under construction<a class="anchor title-text" href="#under-construction">#</a>
</h2></div>

<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="please-can-you-explain-a-simple-model-of-how-the-files-content-is-stored-in-a-simple-i-node-based-filesystem" class="title-text">Please can you explain a simple model of how the file’s content is stored in a simple i-node based filesystem?<a class="anchor title-text" href="#please-can-you-explain-a-simple-model-of-how-the-files-content-is-stored-in-a-simple-i-node-based-filesystem">#</a>
</h2></div>

































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Sure! To answer this question, we’ll build a virtual disk and then write some C code to access its contents. Our filesystem will divide the bytes available into space for inodes and a much larger space for disk blocks. Each disk block will be 4096 bytes-</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-0" onclick="onCopy(this);">Copy</a><span class="c1">// Disk size:</span>
<span class="cp">#define MAX_INODE (1024)
#define MAX_BLOCK (1024*1024)
</span>
<span class="c1">// Each block is 4096 bytes:</span>
<span class="k">typedef</span> <span class="kt">char</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span> <span class="n">block_t</span><span class="p">;</span>

<span class="c1">// A disk is an array of inodes and an array of disk blocks:</span>
<span class="k">struct</span> <span class="n">inode</span><span class="p">[</span><span class="n">MAX_INODE</span><span class="p">]</span> <span class="n">inodes</span><span class="p">;</span>
<span class="n">block</span><span class="p">[</span><span class="n">MAX_BLOCK</span><span class="p">]</span> <span class="n">blocks</span><span class="p">;</span>
<textarea id="code-copy-0" class="code-copy-textarea" value="// Disk size:
#define MAX_INODE (1024)
#define MAX_BLOCK (1024*1024)

// Each block is 4096 bytes:
typedef char[4096] block_t;

// A disk is an array of inodes and an array of disk blocks:
struct inode[MAX_INODE] inodes;
block[MAX_BLOCK] blocks;
"></textarea></code></pre>
<p>Note for clarity we will not use ‘unsigned’ in this code example. Our fixed-sized inodes will contain the file’s size in bytes, permission, user, group information, time meta-data. What is most relevant to the problem-at hand is that it will also include ten pointers to disk blocks that we will use to refer to the actual file’s contents!</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-1" onclick="onCopy(this);">Copy</a><span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
 <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">directblocks</span><span class="p">;</span> <span class="c1">// indices for the block array i.e. where to the find the file's content</span>
 <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
 <span class="c1">// ... standard inode meta-data e.g.</span>
 <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">userid</span><span class="p">,</span><span class="n">groupid</span><span class="p">;</span>
 <span class="kt">time_t</span> <span class="n">ctime</span><span class="p">,</span><span class="n">atime</span><span class="p">,</span><span class="n">mtime</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-1" class="code-copy-textarea" value="struct inode {
 int[10] directblocks; // indices for the block array i.e. where to the find the file's content
 long size;
 // ... standard inode meta-data e.g.
 int mode, userid,groupid;
 time_t ctime,atime,mtime;
}
"></textarea></code></pre>
<p>Now we can work out how to read a byte at offset <code class="highlighter-rouge">position</code> of our file:</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-2" onclick="onCopy(this);">Copy</a><span class="kt">char</span> <span class="nf">readbyte</span><span class="p">(</span><span class="n">inode</span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="kt">long</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">position</span> <span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">position</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// invalid offset</span>

  <span class="kt">int</span>  <span class="n">block_count</span> <span class="o">=</span> <span class="n">position</span> <span class="o">/</span> <span class="mi">4096</span><span class="p">,</span><span class="n">offset</span> <span class="o">=</span> <span class="n">position</span> <span class="o">%</span> <span class="mi">4096</span><span class="p">;</span>
  
  <span class="c1">// block count better be 0..9 !</span>
  <span class="kt">int</span> <span class="n">physical_idx</span> <span class="o">=</span> <span class="n">lookup_physical_block_index</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_count</span> <span class="p">);</span>

  <span class="c1">// sanity check that the disk block index is reasonable...</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">physical_idx</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">physical_idx</span> <span class="o">&lt;</span> <span class="n">MAX_BLOCK</span><span class="p">);</span>


  <span class="c1">// read the disk block from our virtual disk 'blocks' and return the specific byte</span>
  <span class="k">return</span> <span class="n">blocks</span><span class="p">[</span><span class="n">physical_idx</span><span class="p">][</span><span class="n">offset</span><span class="p">];</span>
<span class="p">}</span>
<textarea id="code-copy-2" class="code-copy-textarea" value="char readbyte(inode*inode,long position) {
  if(position &amp;lt;0 || position &amp;gt;= inode-&amp;gt;size) return -1; // invalid offset

  int  block_count = position / 4096,offset = position % 4096;
  
  // block count better be 0..9 !
  int physical_idx = lookup_physical_block_index(inode, block_count );

  // sanity check that the disk block index is reasonable...
  assert(physical_idx &amp;gt;=0 &amp;amp;&amp;amp; physical_idx &amp;lt; MAX_BLOCK);


  // read the disk block from our virtual disk 'blocks' and return the specific byte
  return blocks[physical_idx][offset];
}
"></textarea></code></pre>
<p>Our initial version of lookup_physical_block is simple - we can use our table of 10 direct blocks!</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-3" onclick="onCopy(this);">Copy</a><span class="kt">int</span> <span class="nf">lookup_physical_block_index</span><span class="p">(</span><span class="n">inode</span><span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_count</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">block_count</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">block_count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">directblocks</span><span class="p">[</span> <span class="n">block_count</span> <span class="p">];</span> <span class="c1">// returns an index value between [0,MAX_BLOCK)</span>
<span class="p">}</span>
<textarea id="code-copy-3" class="code-copy-textarea" value="int lookup_physical_block_index(inode*inode, int block_count) {
  assert(block_count&amp;gt;=0 &amp;amp;&amp;amp; block_count &amp;lt; 10);

  return inode-&amp;gt;directblocks[ block_count ]; // returns an index value between [0,MAX_BLOCK)
}
"></textarea></code></pre>
<p>This simple representation is reasonable provided we can represent all possible files with just ten blocks i.e. up to 40KB. What about larger files? We need the inode struct to always be the same size so just increasing the existing direct block array to 20 would roughly double the size of our inodes. If most of our files require less than 10 blocks, then our inode storage is now wasteful. To solve this problem we will use a disk block called the <em>indirect block</em> to extend the array of pointers at our disposal. We will only need this for files &gt; 40KB</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-4" onclick="onCopy(this);">Copy</a><span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
 <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">directblocks</span><span class="p">;</span> <span class="c1">// if size&lt;4KB then only the first one is valid</span>
 <span class="kt">int</span> <span class="n">indirectblock</span><span class="p">;</span> <span class="c1">// valid value when size &gt;= 40KB</span>
 <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
 <span class="p">...</span>
<span class="p">}</span>
<textarea id="code-copy-4" class="code-copy-textarea" value="struct inode {
 int[10] directblocks; // if size&amp;lt;4KB then only the first one is valid
 int indirectblock; // valid value when size &amp;gt;= 40KB
 int size;
 ...
}
"></textarea></code></pre>
<p>The indirect block is just a regular disk block of 4096 bytes, but we will use it to hold pointers to disk blocks. Our pointers in this case are just integers, so we need to cast the pointer to an integer pointer:</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-5" onclick="onCopy(this);">Copy</a><span class="kt">int</span> <span class="nf">lookup_physical_block_index</span><span class="p">(</span><span class="n">inode</span><span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_count</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// Warning this code assumes an index is 4 bytes!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">block_count</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">block_count</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// 0 &lt;= block_count&lt; 1034</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">block_count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">directblocks</span><span class="p">[</span> <span class="n">block_count</span> <span class="p">];</span>
  
  <span class="c1">// read the indirect block from disk:</span>
  <span class="n">block_t</span><span class="o">*</span> <span class="n">oneblock</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">blocks</span><span class="p">[</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">indirectblock</span> <span class="p">];</span>

  <span class="c1">// Treat the 4KB as an array of 1024 pointers to other disk blocks</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">oneblock</span><span class="p">;</span>
  
 <span class="c1">// Look up the correct entry in the table</span>
 <span class="c1">// Offset by 10 because the first 10 blocks of data are already </span>
 <span class="c1">// accounted for</span>
  <span class="k">return</span> <span class="n">table</span><span class="p">[</span> <span class="n">block_count</span> <span class="o">-</span> <span class="mi">10</span> <span class="p">];</span>
<span class="p">}</span>
<textarea id="code-copy-5" class="code-copy-textarea" value="int lookup_physical_block_index(inode*inode, int block_count) {
  assert(sizeof(int)==4); // Warning this code assumes an index is 4 bytes!
  assert(block_count&amp;gt;=0 &amp;amp;&amp;amp; block_count &amp;lt; 1024 + 10); // 0 &amp;lt;= block_count&amp;lt; 1034

  if( block_count &amp;lt; 10)
     return inode-&amp;gt;directblocks[ block_count ];
  
  // read the indirect block from disk:
  block_t* oneblock = &amp;amp; blocks[ inode-&amp;gt;indirectblock ];

  // Treat the 4KB as an array of 1024 pointers to other disk blocks
  int* table = (int*) oneblock;
  
 // Look up the correct entry in the table
 // Offset by 10 because the first 10 blocks of data are already 
 // accounted for
  return table[ block_count - 10 ];
}
"></textarea></code></pre>
<p>For a typical filesystem, our index values are 32 bits i.e. 4bytes. Thus in 4096 bytes we can store 4096 / 4 = 1024 entries.
This means our indirect block can refer to 1024 * 4KB = 4MB of data. With the first ten direct blocks, we can therefore accommodate files up to 40KB + 1024 * 4KB= 4136KB . Some of the later table entries can be invalid for files that are smaller than this.</p>
<p>For even larger files, we could use two indirect blocks. However there’s a better alternative, that will allow us to efficiently scale up to huge files. We will include a double-indirect pointer and if that’s not enough a triple indirect pointer. The double indirect pointer means we have a table of 1024 entries to disk blocks that are used as 1024 entries. This means we can refer to 1024*1024 disk blocks of data.</p>
<p><img src="http://uw714doc.sco.com/en/FS_admin/graphics/s5chain.gif" alt="inode disk blocks for data"></p>
<p>(source: http://uw714doc.sco.com/en/FS_admin/graphics/s5chain.gif)</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-6" onclick="onCopy(this);">Copy</a><span class="kt">int</span> <span class="nf">lookup_physical_block_index</span><span class="p">(</span><span class="n">inode</span><span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block_count</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">block_count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">directblocks</span><span class="p">[</span> <span class="n">block_count</span> <span class="p">];</span>

  <span class="c1">// Use indirect block for the next 1024 blocks:</span>
  <span class="c1">// Assumes 1024 ints can fit inside each block!</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">block_count</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>   
      <span class="kt">int</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">blocks</span><span class="p">[</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">indirectblock</span> <span class="p">];</span>
      <span class="k">return</span> <span class="n">table</span><span class="p">[</span> <span class="n">block_count</span> <span class="o">-</span> <span class="mi">10</span> <span class="p">];</span>
  <span class="p">}</span>
  <span class="c1">// For huge files we will use a table of tables</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_count</span> <span class="o">-</span> <span class="mi">1034</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span> <span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_count</span> <span class="o">-</span> <span class="mi">1034</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">// triple-indirect is not implemented here!</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">table1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">blocks</span><span class="p">[</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">doubleindirectblock</span> <span class="p">];</span>
   <span class="c1">// The first table tells us where to read the second table ...</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">table2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">blocks</span><span class="p">[</span>   <span class="n">table1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="p">];</span>
  <span class="k">return</span> <span class="n">table2</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
 
   <span class="c1">// For gigantic files we will need to implement triple-indirect (table of tables of tables)</span>
<span class="p">}</span>
<textarea id="code-copy-6" class="code-copy-textarea" value="int lookup_physical_block_index(inode*inode, int block_count) {
  if( block_count &amp;lt; 10)
     return inode-&amp;gt;directblocks[ block_count ];

  // Use indirect block for the next 1024 blocks:
  // Assumes 1024 ints can fit inside each block!
  if( block_count &amp;lt; 1024 + 10) {   
      int* table = (int*) &amp;amp; blocks[ inode-&amp;gt;indirectblock ];
      return table[ block_count - 10 ];
  }
  // For huge files we will use a table of tables
  int i = (block_count - 1034) / 1024 , j = (block_count - 1034) % 1024;
  assert(i&amp;lt;1024); // triple-indirect is not implemented here!

  int* table1 = (int*) &amp;amp; blocks[ inode-&amp;gt;doubleindirectblock ];
   // The first table tells us where to read the second table ...
  int* table2 = (int*) &amp;amp; blocks[   table1[i]   ];
  return table2[j];
 
   // For gigantic files we will need to implement triple-indirect (table of tables of tables)
}
"></textarea></code></pre>
<p>Notice that reading a byte using double indirect requires 3 disk block reads (two tables and the actual data block).</p>
</div></div></div>
</div></div>
</div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/file-system-part-9-disk-blocks-example.md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha384-xBuQ/xzmlsLoJpyjoggmTEz8OWUFM0/RC5BsqQBDX2v5cMvDHcMakNTNrHIW2I5f" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-Ra6zh6uYMmH5ydwCqqMoykyf1T/+ZcnOQfFPhDrp2kI4OIxadnhsvvA2vv9A7xYv" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-03-15 14:21:15 +0000"></script>

<script>
$(document).ready(function(){
    $('[data-toggle="popover"]').popover({
      trigger: 'manual',
        container: $(this).attr('id'),
        placement: 'top',
        content: function () {
            return '<div class="hover-hovercard"></div>';
        }
    }).on("mouseenter", function () {
        var _this = this;
        $(this).popover("show");
        $(this).siblings(".popover").on("mouseleave", function () {
            $(_this).popover('hide');
        });
    }).on("mouseleave", function () {
        var _this = this;
        setTimeout(function () {
            if (!$(".popover:hover").length) {
               $(_this).popover("hide")
            }
        }, 100);
    });

    $('[data-toggle="tooltip"]').tooltip();
});

</script>
<script src="/js/analytics.js"></script>
<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
