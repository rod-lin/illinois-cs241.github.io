<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Virtual Memory, Part 1: Introduction to Virtual Memory</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-09-08 16:51:38 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-09-08 16:51:38 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Virtual Memory, Part 1: Introduction to Virtual Memory
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//Virtual-Memory,-Part-1:-Introduction-to-Virtual-Memory">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_what-is-the-mmu" href="#what-is-the-mmu" class="fancy-link">What is the MMU?</a></li>
<li><a id="toc_so-how-do-we-convert-a-virtual-address-into-a-physical-address" href="#so-how-do-we-convert-a-virtual-address-into-a-physical-address" class="fancy-link">So how do we convert a virtual address into a physical address?</a></li>
<li><a id="toc_ex-how-many-pages-are-there-in-a-32bit-machine-assume-page-size-of-4kb" href="#ex-how-many-pages-are-there-in-a-32bit-machine-assume-page-size-of-4kb" class="fancy-link">EX: How many pages are there in a 32bit machine (assume page size of 4KB)?</a></li>
<li><a id="toc_what-is-a-frame" href="#what-is-a-frame" class="fancy-link">What is a frame?</a></li>
<li><a id="toc_what-is-a-page-table-and-how-big-is-it" href="#what-is-a-page-table-and-how-big-is-it" class="fancy-link">What is a page table and how big is it?</a></li>
<li><a id="toc_what-is-the-offset-and-how-is-it-used" href="#what-is-the-offset-and-how-is-it-used" class="fancy-link">What is the offset and how is it used?</a></li>
<li><a id="toc_multi-level-page-tables" href="#multi-level-page-tables" class="fancy-link">Multi-level page tables</a></li>
<li><a id="toc_do-page-tables-make-memory-access-slower-and-whats-a-tlb" href="#do-page-tables-make-memory-access-slower-and-whats-a-tlb" class="fancy-link">Do page tables make memory access slower? (And what’s a TLB)</a></li>
<li><a id="toc_can-frames-be-shared-between-processes-can-they-be-specialized" href="#can-frames-be-shared-between-processes-can-they-be-specialized" class="fancy-link">Can frames be shared between processes? Can they be specialized</a></li>
<li><a id="toc_what-else-is-stored-in-the-page-table-and-why" href="#what-else-is-stored-in-the-page-table-and-why" class="fancy-link">What else is stored in the page table and why?</a></li>
<li><a id="toc_whats-a-page-fault" href="#whats-a-page-fault" class="fancy-link">What’s a page fault?</a></li>
</ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper">
<div class="pad"><div class="card">



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="what-is-virtual-memory">What is Virtual Memory?</h1>
<p>In very simple embedded systems and early computers, processes directly access memory i.e. “Address 1234” corresponds to a particular byte stored in a particular part of physical memory.
In modern systems, this is no longer the case. Instead each process is isolated; and there is a translation process between the address of a particular CPU instruction or piece of data of a process and the actual byte of physical memory (“RAM”). Memory addresses are no longer ‘real’; the process runs inside virtual memory. Virtual memory not only keeps processes safe (because one process cannot directly read or modify another process’s memory) it also allows the system to efficiently allocate and re-allocate portions of memory to different processes.</p>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-the-mmu" class="title-text">What is the MMU?<a class="anchor title-text" href="#what-is-the-mmu">#</a>
</h2></div>
<p>The Memory Management Unit is part of the CPU. It converts a virtual memory address into a physical address. The MMU may also interrupt the CPU if there is currently no mapping from a particular virtual address to a physical address or if the current CPU instruction attempts to write to location that the process only has read-access.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="so-how-do-we-convert-a-virtual-address-into-a-physical-address" class="title-text">So how do we convert a virtual address into a physical address?<a class="anchor title-text" href="#so-how-do-we-convert-a-virtual-address-into-a-physical-address">#</a>
</h2></div>
<p>Imagine you had a 32 bit machine. Pointers can hold 32 bits i.e. they can address 2^32 different locations i.e. 4GB of memory (we will be following the standard convention of one address can hold one byte).</p>

<p>Imagine we had a large table - here’s the clever part - stored in memory! For every possible address (all 4 billion of them) we will store the ‘real’ i.e. physical address. Each physical address will need 4 bytes (to hold the 32 bits).
This scheme would require 16 billion bytes to store all of entries. Oops - our lookup scheme would consume all of the memory that we could possibly buy for our 4GB machine.
We need to do better than this. Our lookup table better be smaller than the memory we have otherwise we will have no space left for our actual programs and operating system data.
The solution is to chunk memory into small regions called ‘pages’ and ‘frames’ and use a lookup table for each page.</p>
</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">





<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="what-is-a-page-how-many-of-them-are-there">What is a page? How many of them are there?</h1>
<p>A page is a block of virtual memory. A typical block size on Linux operating system is 4KB (i.e. 2^12 addresses), though you can find examples of larger blocks.</p>
<p>So rather than talking about individual bytes we can talk about blocks of 4KBs, each block is called a page. We can also number our pages (“Page 0” “Page 1” etc)</p>
<div class="pad"><div class="card">
<div class="title"><h2 id="ex-how-many-pages-are-there-in-a-32bit-machine-assume-page-size-of-4kb" class="title-text">EX: How many pages are there in a 32bit machine (assume page size of 4KB)?<a class="anchor title-text" href="#ex-how-many-pages-are-there-in-a-32bit-machine-assume-page-size-of-4kb">#</a>
</h2></div>
<p>Answer: 2^32 address / 2^12 = 2^20 pages.</p>

<p>Remember that 2^10 is 1024, so 2^20 is a bit more than one million.</p>

<p>For a 64 bit machine, 2^64 / 2^12 = 2^52, which is roughly 10^15 pages.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-a-frame" class="title-text">What is a frame?<a class="anchor title-text" href="#what-is-a-frame">#</a>
</h2></div>
<p>A frame (or sometimes called a ‘page frame’) is a block of <em>physical memory</em> or RAM (=Random Access Memory). This kind of memory is occasionally called ‘primary storage’ (and contrasted with slower, secondary storage such as spinning disks that have lower access times)</p>

<p>A frame is the same number of bytes as a virtual page. If a 32 bit machine has 2^32 (4GB) of RAM, then there will be the same number of them in the addressable space of the machine. It’s unlikely that a 64 bit machine will ever have 2^64 bytes of RAM - can you see why?</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-a-page-table-and-how-big-is-it" class="title-text">What is a page table and how big is it?<a class="anchor title-text" href="#what-is-a-page-table-and-how-big-is-it">#</a>
</h2></div>
<p>A page table is a mapping between a page to the frame.
For example Page 1 might be mapped to frame 45, page 2 mapped to frame 30. Other frames might be currently unused or assigned to other running processes, or used internally by the operating system.</p>

<p>A simple page table is just an array, <code class="highlighter-rouge">int frame = table[ page_num ];</code></p>

<p>For a 32 bit machine with 4KB pages, each entry needs to hold a frame number - i.e. 20 bits because we calculated there are 2^20 frames. That’s 2.5 bytes per entry! In practice, we’ll round that up to 4 bytes per entry and find a use for those spare bits. With 4 bytes per entry x 2^20 entries = 4 MB of physical memory are required to hold the page table.</p>

<p>For a 64 bit machine with 4KB pages, each entry needs 52 bits. Let’s round up to 64 bits (8 bytes) per entry. With 2^52 entries thats 2^55 bytes (roughly 40 peta bytes…) Oops our page table is too large.</p>

<p>In 64 bit architectures memory addresses are sparse, so we need a mechanism to reduce the page table size, given that most of the entries will never be used.</p>

<p><img src="http://www.cs.odu.edu/~cs471w/spring12/lectures/MainMemory_files/image028.jpg" alt=""></p>

<p>A visual example of the page table is here. Imagine accessing an array and grabbing array elements.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-the-offset-and-how-is-it-used" class="title-text">What is the offset and how is it used?<a class="anchor title-text" href="#what-is-the-offset-and-how-is-it-used">#</a>
</h2></div>
<p>Remember our page table maps pages to frames, but each page is a block of contiguous addresses. How do we calculate which particular byte to use inside a particular frame? The solution is to re-use the lowest bits of the virtual memory address directly. For example, suppose our process is reading the following address-
<code class="highlighter-rouge">VirtualAddress = 11110000111100001111000010101010 (binary)</code></p>

<p>On a machine with page size 256 Bytes, then the lowest 8 bits (10101010) will be used as the offset.
The remaining upper bits will be the page number (111100001111000011110000).</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="multi-level-page-tables" class="title-text">Multi-level page tables<a class="anchor title-text" href="#multi-level-page-tables">#</a>
</h2></div>
<p>Multi-level pages are one solution to the page table size issue for 64 bit architectures. We’ll look at the simplest implementation - a two level page table. Each table is a list of pointers that point to the next level of tables, not all sub-tables need to exist. An example, two level page table for a 32 bit architecture is shown below-</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VirtualAddress = 11110000111111110000000010101010 (binary)
                 |_Index1_||        ||          | 10 bit Directory index
                           |_Index2_||          | 10 bit Sub-table index
                                     |__________| 12 bit offset (passed directly to RAM)
</code></pre></div></div>
<p>In the above scheme, determining the frame number requires two memory reads: The topmost 10 bits are used in a directory of page tables. If 2 bytes are used for each entry, we only need 2KB to store this entire directory. Each subtable will point to physical frames (i.e. required 4 bytes to store the 20 bits). However, for processes with only tiny memory needs, we only need to specify entries for low memory address (for the heap and program code) and high memory addresses (for the stack). Each subtable is 1024 entries x 4 bytes i.e. 4KB for each subtable.</p>

<p>Thus the total memory overhead for our multi-level page table has shrunk from 4MB (for the single level implementation) to 3 frames of memory (12KB) ! Here’s why: We need at least one frame for the high level directory and two frames for just two sub-tables. One sub-table is necessary for the low addresses (program code, constants and possibly a tiny heap), the other sub-table is for higher addresses used by the environment and stack. In practice, real programs will likely need more sub-table entries, as each subtable can only reference 1024*4KB = 4MB of address space but the main point still stands - we have significantly reduced the memory overhead required to perform page table look ups.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="do-page-tables-make-memory-access-slower-and-whats-a-tlb" class="title-text">Do page tables make memory access slower? (And what’s a TLB)<a class="anchor title-text" href="#do-page-tables-make-memory-access-slower-and-whats-a-tlb">#</a>
</h2></div>

<p>Yes - Significantly ! (But thanks to clever hardware, usually no…)
Compared to reading or writing memory directly.
For a single page table, our machine is now twice as slow! (Two memory accesses are required)
For a two-level page table, memory access is now three times as slow. (Three memory accesses are required)</p>

<p>To overcome this overhead, the MMU includes an associative cache of recently-used  virtual-page-to-frame lookups. This cache is called the TLB (“translation lookaside buffer”). Everytime a virtual address needs to be translated into a physical memory location, the TLB is queried in parallel to the page table. For most memory accesses of most programs, there is a significant chance that the TLB has cached the results. However if a program does not have good cache coherence (for example is reading from random memory locations of many different pages) then the TLB will not have the result cache and now the MMU must use the much slower page table to determine the physical frame.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/X86_Paging_4K.svg/440px-X86_Paging_4K.svg.png" alt=""></p>

<p>This may be how one splits up a multi level page table.</p>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">

<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="advanced-frames-and-page-protections">Advanced Frames and Page Protections</h1>
<div class="pad"><div class="card">
<div class="title"><h2 id="can-frames-be-shared-between-processes-can-they-be-specialized" class="title-text">Can frames be shared between processes? Can they be specialized<a class="anchor title-text" href="#can-frames-be-shared-between-processes-can-they-be-specialized">#</a>
</h2></div>
<p>Yes! In addition to storing the frame number, the page table can be used to store whether a process can write or only read a particular frame. Read only frames can then be safely shared between multiple processes. For example, the C-library instruction code can be shared between all processes that dynamically load the code into the process memory. Each process can only read that memory. Meaning that if you try to write to a read-only page in memory you will get a <code class="highlighter-rouge">SEGFAULT</code>. That is why sometimes memory accesses segfault and sometimes they don’t, it all depends on if your hardware says that you can access.</p>

<p>In addition, processes can share a page with a child process using the <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code> system call. <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/mmap" class="fancy-link">mmap</a></code> is an interesting call because instead of tying each virtual address to a physical frame, it ties it to something else. That something else can be a file, a GPU unit, or any other memory mapped operation that you can think of! Writing to the memory address may write through to the device or the write may be paused by the operating system but this is a very powerful abstraction because often the operating system is able to perform optimizations (multiple processes memory mapping the same file can have the kernel create one mapping).</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-else-is-stored-in-the-page-table-and-why" class="title-text">What else is stored in the page table and why?<a class="anchor title-text" href="#what-else-is-stored-in-the-page-table-and-why">#</a>
</h2></div>
<p>In addition to read-only bit and usage statistics discussed above, it is common to store at least read-only, modification and execution information.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="whats-a-page-fault" class="title-text">What’s a page fault?<a class="anchor title-text" href="#whats-a-page-fault">#</a>
</h2></div>
<p>A page fault is when a running program tries to access some virtual memory in its address space that is not mapped to physical memory. Page faults will also occur in other situations.</p>

<p>There are three types of Page Faults</p>

<p><strong>Minor</strong> If there is no mapping yet for the page, but it is a valid address. This could be memory asked for by <code class="highlighter-rouge">sbrk(2)</code> but not written to yet meaning that the operating system can wait for the first write before allocating space. The OS simply makes the page, loads it into memory, and moves on.</p>

<p><strong>Major</strong> If the mapping to the page is not in memory but on disk. What this will do is swap the page into memory and swap another page out. If this happens frequently enough, your program is said to <em>thrash</em> the MMU.</p>

<p><strong>Invalid</strong> When you try to write to a non-writable memory address or read to a non-readable memory address. The MMU generates an invalid fault and the OS will usually generate a <code class="highlighter-rouge">SIGSEGV</code> meaning segmentation violation meaning that you wrote outside the segment that you could write to.</p>

<h3 id="read-only-bit" class="title-text">Read-only bit</h3>
<p>The read-only bit marks the page as read-only. Attempts to write to the page will cause a page fault. The page fault will then be handled by the Kernel. Two examples of the read-only page include sharing the c runtime library between multiple processes (for security you wouldn’t want to allow one process to modify the library); and Copy-On-Write where the cost of duplicating a page can be delayed until the first write occurs.</p>

<h3 id="dirty-bit" class="title-text">Dirty bit</h3>
<p>http://en.wikipedia.org/wiki/Page_table#Page_table_data</p>
<blockquote>
  <p>The dirty bit allows for a performance optimization. A page on disk that is paged in to physical memory, then read from, and subsequently paged out again does not need to be written back to disk, since the page hasn’t changed. However, if the page was written to after it’s paged in, its dirty bit will be set, indicating that the page must be written back to the backing store. This strategy requires that the backing store retain a copy of the page after it is paged in to memory. When a dirty bit is not used, the backing store need only be as large as the instantaneous total size of all paged-out pages at any moment. When a dirty bit is used, at all times some pages will exist in both physical memory and the backing store.</p>
</blockquote>

<h3 id="execution-bit" class="title-text">Execution bit</h3>
<p>The execution bit defines whether bytes in a page can be executed as CPU instructions. By disabling a page, it prevents code that is maliciously stored in the process memory (e.g. by stack overflow) from being easily executed. (further reading: http://en.wikipedia.org/wiki/NX_bit#Hardware_background)</p>

<h3 id="find-out-more" class="title-text">Find out more</h3>
<p>A lower level more and more technical discussion of paging and page bits on x86 platform is discussed at [http://wiki.osdev.org/Paging]</p>
</div></div>
</div></div></div>
</div></div>
</div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/virtual-memory-part-1-introduction-to-virtual-memory.md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-09-08 16:51:38 +0000"></script>

<script>
$(document).ready(function() { 
    $("#tuxlink").prop("href", "javascript:;").click(function() { 
        if ("WebkitAppearance" in document.documentElement.style) { 
            var style = document.createElement("style"); 
            style.setAttribute("id", "tuxstyle"); 
            style.appendChild(document.createTextNode("")); 
            document.head.appendChild(style); 
            var sheet = style.sheet;
            sheet.insertRule("::-webkit-scrollbar-thumb {border-radius: 0; background-color: white; -webkit-box-shadow: none;}", 0); 
        } 

        const hackerKey = 'hackerLocalKey';
        const hackerOff = "off";
        const hackerOn = "on";

        if (window.localStorage.getItem(hackerKey) === null) {
            window.localStorage.setItem(hackerKey, hackerOff);
        }

        $("#tuxlink").unbind('click').click(function() { 
            const hackerClass = 'hacker';
            $('html, body, header, nav, table, pre, span, :not(.card-staff) > a, p, h1, h2, h3, h4, h5, h6').toggleClass(hackerClass);
            $('ul, img, pre').toggleClass(hackerClass);
            $('.toc').toggleClass(hackerClass);
            $('.content .highlighter-rouge').toggleClass(hackerClass);
            $('.large-centered.columns').toggleClass(hackerClass);
            $('.pad').toggleClass(hackerClass);
            $('a').toggleClass(hackerClass);
            $('tbody tr:nth-child(2n+1)').toggleClass(hackerClass);
            $("#tuxlink img").toggleClass(hackerClass);

            const val = window.localStorage.getItem(hackerKey);
            if (val === hackerOff) {
                window.localStorage.setItem(hackerKey, hackerOn);
            } else {
                window.localStorage.setItem(hackerKey, hackerOff);
            }
            return false; 
        }); 
        $("#tuxlink").click();
        const stored = window.localStorage.getItem(hackerKey);
        if (stored === hackerOn) {
            console.log("Hello!")
            $("#tuxlink").click();
        } else {
            console.log("Noo");
        }

        return false; 
    }); 
    } 
    ); 
    </script>

<script src="/js/analytics.js"></script>

<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
