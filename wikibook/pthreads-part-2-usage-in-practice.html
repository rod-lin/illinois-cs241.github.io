<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Pthreads, Part 2: Usage in Practice</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-09-08 16:51:38 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-09-08 16:51:38 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Pthreads, Part 2: Usage in Practice
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//Pthreads,-Part-2:-Usage-in-Practice">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc">
<li><a id="toc_how-do-i-create-a-pthread" href="#how-do-i-create-a-pthread" class="fancy-link">How do I create a pthread?</a></li>
<li><a id="toc_if-i-call-pthread_create-twice-how-many-stacks-does-my-process-have" href="#if-i-call-pthread_create-twice-how-many-stacks-does-my-process-have" class="fancy-link">If I call <code class="highlighter-rouge">pthread_create</code> twice, how many stacks does my process have?</a></li>
<li><a id="toc_what-is-the-difference-between-a-full-process-and-a-thread" href="#what-is-the-difference-between-a-full-process-and-a-thread" class="fancy-link">What is the difference between a full process and a thread?</a></li>
<li><a id="toc_what-does-pthread_cancel-do" href="#what-does-pthread_cancel-do" class="fancy-link">What does <code class="highlighter-rouge">pthread_cancel</code> do?</a></li>
<li><a id="toc_what-is-the-difference-between-exit-and-pthread_exit" href="#what-is-the-difference-between-exit-and-pthread_exit" class="fancy-link">What is the difference between <code class="highlighter-rouge">exit</code> and <code class="highlighter-rouge">pthread_exit</code>?</a></li>
<li><a id="toc_how-can-a-thread-be-terminated" href="#how-can-a-thread-be-terminated" class="fancy-link">How can a thread be terminated?</a></li>
<li><a id="toc_what-is-the-purpose-of-pthread_join" href="#what-is-the-purpose-of-pthread_join" class="fancy-link">What is the purpose of pthread_join?</a></li>
<li><a id="toc_what-happens-if-you-dont-call-pthread_join" href="#what-happens-if-you-dont-call-pthread_join" class="fancy-link">What happens if you don’t call <code class="highlighter-rouge">pthread_join</code>?</a></li>
<li><a id="toc_should-i-use-pthread_exit-or-pthread_join" href="#should-i-use-pthread_exit-or-pthread_join" class="fancy-link">Should I use <code class="highlighter-rouge">pthread_exit</code> or <code class="highlighter-rouge">pthread_join</code>?</a></li>
<li><a id="toc_can-you-pass-pointers-to-stack-variables-from-one-thread-to-another" href="#can-you-pass-pointers-to-stack-variables-from-one-thread-to-another" class="fancy-link">Can you pass pointers to stack variables from one thread to another?</a></li>
<li><a id="toc_how-can-i-create-ten-threads-with-different-starting-values" href="#how-can-i-create-ten-threads-with-different-starting-values" class="fancy-link">How can I create ten threads with different starting values.</a></li>
<li><a id="toc_why-are-some-functions-eg--asctimegetenv-strtok-strerror--not-thread-safe" href="#why-are-some-functions-eg--asctimegetenv-strtok-strerror--not-thread-safe" class="fancy-link">Why are some functions e.g.  asctime,getenv, strtok, strerror  not thread-safe?</a></li>
<li><a id="toc_what-are-condition-variables-semaphores-mutexes" href="#what-are-condition-variables-semaphores-mutexes" class="fancy-link">What are condition variables, semaphores, mutexes?</a></li>
<li><a id="toc_are-there-any-advantages-of-using-threads-over-forking-processes" href="#are-there-any-advantages-of-using-threads-over-forking-processes" class="fancy-link">Are there any advantages of using threads over forking processes?</a></li>
<li><a id="toc_are-there-any-dis-advantages-of-using-threads-over-forking-processes" href="#are-there-any-dis-advantages-of-using-threads-over-forking-processes" class="fancy-link">Are there any dis-advantages of using threads over forking processes?</a></li>
<li><a id="toc_can-you-fork-a-process-with-multiple-threads" href="#can-you-fork-a-process-with-multiple-threads" class="fancy-link">Can you fork a process with multiple threads?</a></li>
<li><a id="toc_are-there-other-reasons-where-fork-might-be-preferable-to-creating-a-thread" href="#are-there-other-reasons-where-fork-might-be-preferable-to-creating-a-thread" class="fancy-link">Are there other reasons where <code class="highlighter-rouge">fork</code> might be preferable to creating a thread.</a></li>
<li><a id="toc_how-can-i-find-out-more" href="#how-can-i-find-out-more" class="fancy-link">How can I find out more?</a></li>
</ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper">
<div class="pad"><div class="card">

<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="more-pthread-functions">More pthread functions</h1>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-do-i-create-a-pthread" class="title-text">How do I create a pthread?<a class="anchor title-text" href="#how-do-i-create-a-pthread">#</a>
</h2></div>
<p>See <a href="/wikibook/pthreads-part-1-introduction.html#" class="fancy-link wiki-link">Pthreads Part 1</a> which introduces <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_create" class="fancy-link">pthread_create</a></code> and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_join" class="fancy-link">pthread_join</a></code></p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="if-i-call-pthread_create-twice-how-many-stacks-does-my-process-have" class="title-text">If I call <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_create" class="fancy-link">pthread_create</a></code> twice, how many stacks does my process have?<a class="anchor title-text" href="#if-i-call-pthread_create-twice-how-many-stacks-does-my-process-have">#</a>
</h2></div>
<p>Your process will contain three stacks - one for each thread. The first thread is created when the process starts, and you created two more. Actually there can be more stacks than this, but let’s ignore that complication for now. The important idea is that each thread requires a stack because the stack contains automatic variables and the old CPU PC register, so that it can back to executing the calling function after the function is finished.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-the-difference-between-a-full-process-and-a-thread" class="title-text">What is the difference between a full process and a thread?<a class="anchor title-text" href="#what-is-the-difference-between-a-full-process-and-a-thread">#</a>
</h2></div>
<p>In addition, unlike processes, threads within the same process can share the same global memory (data and heap segments).</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-does-pthread_cancel-do" class="title-text">What does <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cancel" class="fancy-link">pthread_cancel</a></code> do?<a class="anchor title-text" href="#what-does-pthread_cancel-do">#</a>
</h2></div>
<p>Stops a thread. Note the thread may not actually be stopped immediately. For example it can be terminated when the thread makes an operating system call (e.g. <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/write" class="fancy-link">write</a></code>).</p>

<p>In practice, <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cancel" class="fancy-link">pthread_cancel</a></code> is rarely used because it does not give a thread an opportunity to clean up after itself (for example, it may have opened some files).
An alternative implementation is to use a boolean (int) variable whose value is used to inform other threads that they should finish and clean up.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-the-difference-between-exit-and-pthread_exit" class="title-text">What is the difference between <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/exit" class="fancy-link">exit</a></code> and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code>?<a class="anchor title-text" href="#what-is-the-difference-between-exit-and-pthread_exit">#</a>
</h2></div>
<p><code class="highlighter-rouge">exit(42)</code> exits the entire process and sets the processes exit value.  This is equivalent to <code class="highlighter-rouge">return 42</code> in the main method. All threads inside the process are stopped.</p>

<p><code class="highlighter-rouge">pthread_exit(void *)</code> only stops the calling thread i.e. the thread never returns after calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code>. The pthread library will automatically finish the process if there are no other threads running. <code class="highlighter-rouge">pthread_exit(...)</code> is equivalent to returning from the thread’s function; both finish the thread and also set the return value (void *pointer) for the thread.</p>

<p>Calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code> in the the <code class="highlighter-rouge">main</code> thread is a common way for simple programs to ensure that all threads finish. For example, in the following program, the  <code class="highlighter-rouge">myfunc</code> threads will probably not have time to get started.</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-0" onclick="onCopy(this);">Copy</a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="s">"Jabberwocky"</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="s">"Vorpel"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">//or return 42;</span>

  <span class="c1">// No code is run after exit</span>
<span class="p">}</span>
<textarea id="code-copy-0" class="code-copy-textarea" value='int main() {
  pthread_t tid1, tid2;
  pthread_create(&amp;amp;tid1, NULL, myfunc, "Jabberwocky");
  pthread_create(&amp;amp;tid2, NULL, myfunc, "Vorpel");
  exit(42); //or return 42;

  // No code is run after exit
}
'></textarea></code></pre>
<p>The next two programs will wait for the new threads to finish-</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-1" onclick="onCopy(this);">Copy</a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="s">"Jabberwocky"</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="s">"Vorpel"</span><span class="p">);</span>
  <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> 

  <span class="c1">// No code is run after pthread_exit</span>
  <span class="c1">// However process will continue to exist until both threads have finished</span>
<span class="p">}</span>
<textarea id="code-copy-1" class="code-copy-textarea" value='int main() {
  pthread_t tid1, tid2;
  pthread_create(&amp;amp;tid1, NULL, myfunc, "Jabberwocky");
  pthread_create(&amp;amp;tid2, NULL, myfunc, "Vorpel");
  pthread_exit(NULL); 

  // No code is run after pthread_exit
  // However process will continue to exist until both threads have finished
}
'></textarea></code></pre>
<p>Alternatively, we join on each thread (i.e. wait for it to finish) before we return from main (or call exit).</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-2" onclick="onCopy(this);">Copy</a><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="s">"Jabberwocky"</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="s">"Vorpel"</span><span class="p">);</span>
  <span class="c1">// wait for both threads to finish :</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span> 
  <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-2" class="code-copy-textarea" value='int main() {
  pthread_t tid1, tid2;
  pthread_create(&amp;amp;tid1, NULL, myfunc, "Jabberwocky");
  pthread_create(&amp;amp;tid2, NULL, myfunc, "Vorpel");
  // wait for both threads to finish :
  void* result;
  pthread_join(tid1, &amp;amp;result);
  pthread_join(tid2, &amp;amp;result); 
  return 42;
}
'></textarea></code></pre>
<p>Note the pthread_exit version creates thread zombies, however this is not a long-running processes, so we don’t care.</p>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-can-a-thread-be-terminated" class="title-text">How can a thread be terminated?<a class="anchor title-text" href="#how-can-a-thread-be-terminated">#</a>
</h2></div>
<ul>
  <li>Returning from the thread function</li>
  <li>Calling <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code>
</li>
  <li>Cancelling the thread with <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_cancel" class="fancy-link">pthread_cancel</a></code>
</li>
  <li>Terminating the process (e.g. SIGTERM); exit(); returning from <code class="highlighter-rouge">main</code>
</li>
</ul>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-is-the-purpose-of-pthread_join" class="title-text">What is the purpose of pthread_join?<a class="anchor title-text" href="#what-is-the-purpose-of-pthread_join">#</a>
</h2></div>
<ul>
  <li>Wait for a thread to finish</li>
  <li>Clean up thread resources</li>
  <li>Grabs the return value of the thread</li>
</ul>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-happens-if-you-dont-call-pthread_join" class="title-text">What happens if you don’t call <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_join" class="fancy-link">pthread_join</a></code>?<a class="anchor title-text" href="#what-happens-if-you-dont-call-pthread_join">#</a>
</h2></div>
<p>Finished threads will continue to consume resources. Eventually, if enough threads are created, <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_create" class="fancy-link">pthread_create</a></code> will fail.
In practice, this is only an issue for long-running processes but is not an issue for simple, short-lived processes as all thread resources are automatically freed when the process exits.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="should-i-use-pthread_exit-or-pthread_join" class="title-text">Should I use <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code> or <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_join" class="fancy-link">pthread_join</a></code>?<a class="anchor title-text" href="#should-i-use-pthread_exit-or-pthread_join">#</a>
</h2></div>
<p>Both <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code> and <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_join" class="fancy-link">pthread_join</a></code> will let the other threads finish on their own (even if called in the main thread). However, only <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_join" class="fancy-link">pthread_join</a></code> will return to you when the specified thread finishes. <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_exit" class="fancy-link">pthread_exit</a></code> does not wait and will immediately end your thread and give you no chance to continue executing.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="can-you-pass-pointers-to-stack-variables-from-one-thread-to-another" class="title-text">Can you pass pointers to stack variables from one thread to another?<a class="anchor title-text" href="#can-you-pass-pointers-to-stack-variables-from-one-thread-to-another">#</a>
</h2></div>
<p>Yes. However you need to be very careful about the lifetime of stack variables.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pthread_t start_threads() {
  int start = 42;
  pthread_t tid;
  pthread_create(&amp;tid, 0, myfunc, &amp;start); // ERROR!
  return tid;
}
</code></pre></div></div>
<p>The above code is invalid because the function <code class="highlighter-rouge">start_threads</code> will likely return before <code class="highlighter-rouge">myfunc</code> even starts. The function passes the address-of <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/start" class="fancy-link">start</a></code>, however by the time <code class="highlighter-rouge">myfunc</code> is executes, <code class="highlighter-rouge"><a href="https://linux.die.net/man/1/start" class="fancy-link">start</a></code> is no longer in scope and its address will re-used for another variable.</p>

<p>The following code is valid because the lifetime of the stack variable is longer than the background thread.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void start_threads() {
  int start = 42;
  void *result;
  pthread_t tid;
  pthread_create(&amp;tid, 0, myfunc, &amp;start); // OK - start will be valid!
  pthread_join(tid, &amp;result);
}
</code></pre></div></div>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">

<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="intro-to-race-conditions">Intro to Race Conditions</h1>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-can-i-create-ten-threads-with-different-starting-values" class="title-text">How can I create ten threads with different starting values.<a class="anchor title-text" href="#how-can-i-create-ten-threads-with-different-starting-values">#</a>
</h2></div>
<p>The following code is supposed to start ten threads with values 0,1,2,3,…9
However, when run prints out <code class="highlighter-rouge">1 7 8 8 8 8 8 8 8 10</code>! Can you see why?</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-3" onclick="onCopy(this);">Copy</a><span class="cp">#include &lt;pthread.h&gt;
</span><span class="kt">void</span><span class="o">*</span> <span class="nf">myfunc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Each thread gets a different value of i to process</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myfunc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">// ERROR</span>
    <span class="p">}</span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<textarea id="code-copy-3" class="code-copy-textarea" value='#include &amp;lt;pthread.h&amp;gt;
void* myfunc(void* ptr) {
    int i = *((int *) ptr);
    printf("%d ", i);
    return NULL;
}

int main() {
    // Each thread gets a different value of i to process
    int i;
    pthread_t tid;
    for(i =0; i &amp;lt; 10; i++) {
        pthread_create(&amp;amp;tid, NULL, myfunc, &amp;amp;i); // ERROR
    }
    pthread_exit(NULL);
}
'></textarea></code></pre>
<p>The above code suffers from a <code class="highlighter-rouge">race condition</code> - the value of i is changing. The new threads start later (in the example output the last thread starts after the loop has finished).</p>

<p>To overcome this race-condition, we will give each thread a pointer to it’s own data area. For example, for each thread we may want to store the id, a starting value and an output value:</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-4" onclick="onCopy(this);">Copy</a><span class="k">struct</span> <span class="n">T</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">id</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">result</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
<textarea id="code-copy-4" class="code-copy-textarea" value="struct T {
  pthread_t id;
  int start;
  char result[100];
};
"></textarea></code></pre>
<p>These can be stored in an array -</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct T *info = calloc(10 , sizeof(struct T)); // reserve enough bytes for ten T structures
</code></pre></div></div>
<p>And each array element passed to each thread -</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pthread_create(&amp;info[i].id, NULL, func, &amp;info[i]);
</code></pre></div></div>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="why-are-some-functions-eg--asctimegetenv-strtok-strerror--not-thread-safe" class="title-text">Why are some functions e.g.  asctime,getenv, strtok, strerror  not thread-safe?<a class="anchor title-text" href="#why-are-some-functions-eg--asctimegetenv-strtok-strerror--not-thread-safe">#</a>
</h2></div>
<p>To answer this, let’s look at a simple function that is also not ‘thread-safe’</p>
<pre><code class="language-C"><a class="code-copy" rel="code-copy-5" onclick="onCopy(this);">Copy</a><span class="kt">char</span> <span class="o">*</span><span class="nf">to_message</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="k">static</span> <span class="n">result</span> <span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">"%d : blah blah"</span> <span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">"Unknown"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<textarea id="code-copy-5" class="code-copy-textarea" value='char *to_message(int num) {
    char static result [256];
    if (num &amp;lt; 10) sprintf(result, "%d : blah blah" , num);
    else strcpy(result, "Unknown");
    return result;
}
'></textarea></code></pre>
<p>In the above code the result buffer is stored in global memory. This is good - we wouldn’t want to return a pointer to an invalid address on the stack, but there’s only one result buffer in the entire memory. If two threads were to use it at the same time then one would corrupt the other:</p>

<table class="table">
  <thead>
    <tr>
      <th>Time</th>
      <th>Thread 1</th>
      <th>Thread 2</th>
      <th>Comments</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>to_m(5 )</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>2</td>
      <td> </td>
      <td>to_m(99)</td>
      <td>Now both threads will see “Unknown” stored in the result buffer</td>
    </tr>
  </tbody>
</table>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="what-are-condition-variables-semaphores-mutexes" class="title-text">What are condition variables, semaphores, mutexes?<a class="anchor title-text" href="#what-are-condition-variables-semaphores-mutexes">#</a>
</h2></div>
<p>These are synchronization locks that are used to prevent race conditions and ensure proper synchronization between threads running in the same program. In addition, these locks are conceptually identical to the primitives used inside the kernel.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="are-there-any-advantages-of-using-threads-over-forking-processes" class="title-text">Are there any advantages of using threads over forking processes?<a class="anchor title-text" href="#are-there-any-advantages-of-using-threads-over-forking-processes">#</a>
</h2></div>
<p>Yes! Sharing information between threads is easy because threads (of the same process) live inside the same virtual memory space.
Also, creating a thread is significantly faster than creating(forking) a process.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="are-there-any-dis-advantages-of-using-threads-over-forking-processes" class="title-text">Are there any dis-advantages of using threads over forking processes?<a class="anchor title-text" href="#are-there-any-dis-advantages-of-using-threads-over-forking-processes">#</a>
</h2></div>
<p>Yes! No- isolation! As threads live inside the same process, one thread has access to the same virtual memory as the other threads. A single thread can terminate the entire process (e.g. by trying to read address zero).</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="can-you-fork-a-process-with-multiple-threads" class="title-text">Can you fork a process with multiple threads?<a class="anchor title-text" href="#can-you-fork-a-process-with-multiple-threads">#</a>
</h2></div>
<p>Yes! However the child process only has a single thread (which is a clone of the thread that called <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fork" class="fancy-link">fork</a></code>. We can see this as a simple example, where the background threads never print out a second message in the child process.</p>

<pre><code class="language-C"><a class="code-copy" rel="code-copy-6" onclick="onCopy(this);">Copy</a><span class="cp">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="k">static</span> <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">sleepnprint</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d:%s starting up...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span> <span class="cm">/* Later we will use condition variables */</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%d:%s finishing...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sleepnprint</span><span class="p">,</span> <span class="s">"New Thread One"</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sleepnprint</span><span class="p">,</span> <span class="s">"New Thread Two"</span><span class="p">);</span>
  
  <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">(),</span> <span class="s">"fork()ing complete"</span><span class="p">);</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">(),</span> <span class="s">"Main thread finished"</span><span class="p">);</span>
  
  <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Never executes */</span>
<span class="p">}</span>
<textarea id="code-copy-6" class="code-copy-textarea" value='#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

static pid_t child = -2;

void *sleepnprint(void *arg) {
  printf("%d:%s starting up...\n", getpid(), (char *) arg);

  while (child == -2) {sleep(1);} /* Later we will use condition variables */

  printf("%d:%s finishing...\n",getpid(), (char*)arg);

  return NULL;  
}
int main() {
  pthread_t tid1, tid2;
  pthread_create(&amp;amp;tid1,NULL, sleepnprint, "New Thread One");
  pthread_create(&amp;amp;tid2,NULL, sleepnprint, "New Thread Two");
  
  child = fork();
  printf("%d:%s\n",getpid(), "fork()ing complete");
  sleep(3);
    
  printf("%d:%s\n",getpid(), "Main thread finished");
  
  pthread_exit(NULL);
  return 0; /* Never executes */
}
'></textarea></code></pre>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>8970:New Thread One starting up...
8970:fork()ing complete
8973:fork()ing complete
8970:New Thread Two starting up...
8970:New Thread Two finishing...
8970:New Thread One finishing...
8970:Main thread finished
8973:Main thread finished
</code></pre></div></div>

<p>In practice, creating threads before forking can lead to unexpected errors because (as demonstrated above) the other threads are immediately terminated when forking. Another thread might have just lock a mutex (e.g. by calling malloc) and never unlock it again. Advanced users may find <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/pthread_atfork" class="fancy-link">pthread_atfork</a></code> useful however we suggest you usually try to avoid creating threads before forking unless you fully understand the limitations and difficulties of this approach.</p>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="are-there-other-reasons-where-fork-might-be-preferable-to-creating-a-thread" class="title-text">Are there other reasons where <code class="highlighter-rouge"><a href="https://linux.die.net/man/3/fork" class="fancy-link">fork</a></code> might be preferable to creating a thread.<a class="anchor title-text" href="#are-there-other-reasons-where-fork-might-be-preferable-to-creating-a-thread">#</a>
</h2></div>
<p>Creating separate processes is useful</p>
<ul>
  <li>When more security is desired (for example, Chrome browser uses different processes for different tabs)</li>
  <li>When running an existing and complete program then a new process is required (e.g. starting ‘gcc’)</li>
  <li>When you are running into synchronization primitives and each process is operating on something in the system</li>
</ul>

</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="how-can-i-find-out-more" class="title-text">How can I find out more?<a class="anchor title-text" href="#how-can-i-find-out-more">#</a>
</h2></div>
<p>See the complete example in the <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" class="fancy-link wiki-link">man page</a>
And the <a href="http://man7.org/linux/man-pages/man7/pthreads.7.html" class="fancy-link wiki-link">pthread reference guide</a>
ALSO: <a href="http://www.thegeekstuff.com/2012/04/terminate-c-thread/" class="fancy-link wiki-link">Concise third party sample code explaining create, join and exit</a></p>
</div></div>
</div></div></div>
</div></div>
</div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/pthreads-part-2-usage-in-practice.md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-09-08 16:51:38 +0000"></script>

<script>
$(document).ready(function() { 
    $("#tuxlink").prop("href", "javascript:;").click(function() { 
        if ("WebkitAppearance" in document.documentElement.style) { 
            var style = document.createElement("style"); 
            style.setAttribute("id", "tuxstyle"); 
            style.appendChild(document.createTextNode("")); 
            document.head.appendChild(style); 
            var sheet = style.sheet;
            sheet.insertRule("::-webkit-scrollbar-thumb {border-radius: 0; background-color: white; -webkit-box-shadow: none;}", 0); 
        } 

        const hackerKey = 'hackerLocalKey';
        const hackerOff = "off";
        const hackerOn = "on";

        if (window.localStorage.getItem(hackerKey) === null) {
            window.localStorage.setItem(hackerKey, hackerOff);
        }

        $("#tuxlink").unbind('click').click(function() { 
            const hackerClass = 'hacker';
            $('html, body, header, nav, table, pre, span, :not(.card-staff) > a, p, h1, h2, h3, h4, h5, h6').toggleClass(hackerClass);
            $('ul, img, pre').toggleClass(hackerClass);
            $('.toc').toggleClass(hackerClass);
            $('.content .highlighter-rouge').toggleClass(hackerClass);
            $('.large-centered.columns').toggleClass(hackerClass);
            $('.pad').toggleClass(hackerClass);
            $('a').toggleClass(hackerClass);
            $('tbody tr:nth-child(2n+1)').toggleClass(hackerClass);
            $("#tuxlink img").toggleClass(hackerClass);

            const val = window.localStorage.getItem(hackerKey);
            if (val === hackerOff) {
                window.localStorage.setItem(hackerKey, hackerOn);
            } else {
                window.localStorage.setItem(hackerKey, hackerOff);
            }
            return false; 
        }); 
        $("#tuxlink").click();
        const stored = window.localStorage.getItem(hackerKey);
        if (stored === hackerOn) {
            console.log("Hello!")
            $("#tuxlink").click();
        } else {
            console.log("Noo");
        }

        return false; 
    }); 
    } 
    ); 
    </script>

<script src="/js/analytics.js"></script>

<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
