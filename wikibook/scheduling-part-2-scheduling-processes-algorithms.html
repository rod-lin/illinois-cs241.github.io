<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="apple-touch-icon" sizes="180x180" href="images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="images/favicons/manifest.json">
  <link rel="mask-icon" href="images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>Scheduling, Part 2: Scheduling Processes: Algorithms</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <link async rel="stylesheet" href="/css/code-style.css?v=2018-09-08 16:51:38 +0000">
  <link rel="stylesheet" href="/css/main.css?v=2018-09-08 16:51:38 +0000">

</head>

<body>
<!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>

            <a id="tuxlink"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAJCAMAAAA4jZ0cAAAAM1BMVEX///8CAgQMDAwsLCw0NDSjbQCkbQC+vbzOkwDU1NTlrADqvADxtgD0vQD12wD+/vz+//yBSdYEAAAAAXRSTlMAQObYZgAAADFJREFUCB0FwQkCQDAQBLCsq6g1/v9aCVQBthUwX8BIgStZCpUvKXSSLs6eyd0Pdg5+JwkBVyC74QYAAAAASUVORK5CYII=" title="Tux" alt="Tux" style="margin-left: 1em; width: 24px; filter: drop-shadow(1px 1px 0 white) drop-shadow(1px -1px 0 white) drop-shadow(-1px 1px 0 white) drop-shadow(-1px -1px 0 white); margin-top: 1em;"/></a>

            <a class="navbar-brand navbar-link normal" href="/">CS 241: System Programming</a>
            <a class="navbar-brand navbar-link small" href="/">CS 241</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
            <a class="navbar-link" href="/mps.html">MPs</a>
            </li>
            <li>
            <a class="navbar-link" href="/labs.html">Labs</a>
            </li>
            <li>
            <a class="navbar-link" href="/help.html">Help!</a>
            </li>
            <li>
            <a class="navbar-link" href="/schedule.html">Schedule</a>
            </li>
            <li>
            <a class="navbar-link" href="/honors.html">Honors</a>
            </li>
            <li>
            <a class="navbar-link" href="/staff.html">The Crew</a>
            </li>
            <li>
            <a class="navbar-link" href="/search.html">Search</a>
            </li>
            <li>
            <a class="navbar-link" href="/wikibook/home.html">Wikibook</a>
            </li>
          </ul>
        </div>
        </div>
</nav>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-2 col-sm-1 col-xs-0"></div>
    <div class="col-md-8 col-sm-10 col-xs-12">
      <div class="wrapper">
        <div class="pad"><div class="card">
          <div class="title">
            <div class="speaker-wrapper">
              <button onclick="speak()" class="speaker" alt="Read Page"></button>
            </div>
            <h1>
              Scheduling, Part 2: Scheduling Processes: Algorithms
              
                <a class="github-link hidden-xs" href="https://github.com/angrave/SystemProgramming/wiki//Scheduling,-Part-2:-Scheduling-Processes:-Algorithms">Edit on Github</a>
              
            </h1>
          </div>
          <div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
            
          </div></div></div>
        </div></div>
      </div>
      <div class="toc-wrapper">
<h4>Content</h4>
<ul class="toc"></ul>
</div>
      <div id="content">
        
        <div class="wrapper">

</div>
        <div class="wrapper">
<div class="pad"><div class="card">













<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="what-are-some-well-known-scheduling-algorithms">What are some well known scheduling algorithms?</h1>
<p>For all the examples,</p>
<p>Process 1: Runtime 1000ms</p>
<p>Process 2: Runtime 2000ms</p>
<p>Process 3: Runtime 3000ms</p>
<p>Process 4: Runtime 4000ms</p>
<p>Process 5: Runtime 5000ms</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="shortest-job-first-sjf">Shortest Job First (SJF)</h1>
<p><img src="http://i.imgur.com/jGLvjqT.png" alt=""></p>
<ul>
  <li>P1 Arrival: 0ms</li>
  <li>P2 Arrival: 0ms</li>
  <li>P3 Arrival: 0ms</li>
  <li>P4 Arrival: 0ms</li>
  <li>P5 Arrival: 0ms</li>
</ul>
<p>The processes all arrive at the start and the scheduler schedules the job with the shortest total CPU time. The glaring problem is that this scheduler needs to know how long this program will run over time before it ran the program.</p>
<p>Technical Note: A realistic SJF implementation would not use the total execution time of the process but the burst time (the total CPU time including future computational execution before the process will no longer be ready to run). The expected burst time can be estimated by using an exponentially decaying weighted rolling average based on the previous burst time but for this exposition we will simplify this discussion to use the total running time of the process as a proxy for the burst time.</p>
<p><strong>Advantages</strong></p>
<ul>
  <li>Shorter jobs tend to get run first</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
  <li>Needs algorithm to be omniscient</li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="preemptive-shortest-job-first-psjf">Preemptive Shortest Job First (PSJF)</h1>
<p>Preemptive shortest job first is like shortest job first but if a new job comes in with a shorter runtime than the total runtime of the current job, it is run instead. (If it is equal like our example our algorithm can choose). The scheduler uses the <em>total</em> runtime of the process. If you want the shortest <em>remaining</em> time left, that is a variant of PSJF called Shortest Remaining Time First (SRTF).</p>
<p><img src="http://i.imgur.com/QvoX7Ia.png" alt=""></p>
<ul>
  <li>P2 at 0ms</li>
  <li>P1 at 1000ms</li>
  <li>P5 at 3000ms</li>
  <li>P4 at 4000ms</li>
  <li>P3 at 5000ms</li>
</ul>
<p>Here’s what our algorithm does. It runs P2 because it is the only thing to run. Then P1 comes in at 1000ms, P2 runs for 2000ms, so our scheduler preemptively stops P2, and let’s P1 run all the way through (this is completely up to the algorithm because the times are equal). Then, P5 Comes in – since there are no processes running, the scheduler will run process 5. P4 comes in, and since the runtimes are equal P5, the scheduler stops P5 and runs P4. Finally P3 comes in, preempts P4, and runs to completion. Then P4 runs, then P5 runs.</p>
<p><strong>Advantages</strong></p>
<ul>
  <li>Ensures shorter jobs get run first</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
  <li>Need to know the runtime again</li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="first-come-first-served-fcfs">First Come First Served (FCFS)</h1>
<p><img src="http://i.imgur.com/lcMpUZz.png" alt=""></p>
<ul>
  <li>P2 at 0ms</li>
  <li>P1 at 1000ms</li>
  <li>P5 at 3000ms</li>
  <li>P4 at 4000ms</li>
  <li>P3 at 5000ms</li>
</ul>
<p>Processes are scheduled in the order of arrival. One advantage of FCFS is that scheduling algorithm is simple: the ready queue is a just a FIFO (first in first out) queue.
FCFS suffers from the Convoy effect.</p>
<p>Here P2 Arrives, then P1 arrives, then P5, then P4, then P3. You can see the convoy effect for P5.</p>
<p><strong>Advantages</strong></p>
<ul>
  <li>Simple implementation</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
  <li>Long running processes could block all other processes</li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">

















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="round-robin-rr">Round Robin (RR)</h1>
<p>Processes are scheduled in order of their arrival in the ready queue. However after a small time step a running process will be forcibly removed from the running state and placed back on the ready queue. This ensures that a long-running process can not starve all other processes from running.
The maximum amount of time that a process can execute before being returned to the ready queue is called the time quanta. In the limit of large time quanta (where the time quanta is longer than the running time of all processes) round robin will be equivalent to FCFS.</p>
<p><img src="http://i.imgur.com/AlBYi0Y.png" alt=""></p>
<ul>
  <li>P1 Arrival: 0ms</li>
  <li>P2 Arrival: 0ms</li>
  <li>P3 Arrival: 0ms</li>
  <li>P4 Arrival: 0ms</li>
  <li>P5 Arrival: 0ms</li>
</ul>
<p>Quantum = 1000ms</p>
<p>Here all processes arrive at the same time. P1 is run for 1 quantum and is finished. P2 for one quantum; then, it is stopped for P3. After all other processes run for a quantum we cycle back to P2 until all the processes are finished.</p>
<p><strong>Advantages</strong></p>
<ul>
  <li>Ensures some notion of fairness</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
  <li>Large number of processes = Lots of switching</li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">


<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<h1 id="priority">Priority</h1>
<p>Processes are scheduled in the order of priority value. For example, a navigation process might be more important to execute than a logging process.</p>
</div></div></div>
</div></div>
</div>
        
        <div class="wrapper">
</div>
      </div>
      <div class="col-md-2 col-sm-1 col-xs-0"></div>
    </div>
  </div>
  <script>
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_wikibook/scheduling-part-2-scheduling-processes-algorithms.md";
  </script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>
<script src="/js/main.js?v=2018-09-08 16:51:38 +0000"></script>

<script>
$(document).ready(function() { 
    $("#tuxlink").prop("href", "javascript:;").click(function() { 
        if ("WebkitAppearance" in document.documentElement.style) { 
            var style = document.createElement("style"); 
            style.setAttribute("id", "tuxstyle"); 
            style.appendChild(document.createTextNode("")); 
            document.head.appendChild(style); 
            var sheet = style.sheet;
            sheet.insertRule("::-webkit-scrollbar-thumb {border-radius: 0; background-color: white; -webkit-box-shadow: none;}", 0); 
        } 

        const hackerKey = 'hackerLocalKey';
        const hackerOff = "off";
        const hackerOn = "on";

        if (window.localStorage.getItem(hackerKey) === null) {
            window.localStorage.setItem(hackerKey, hackerOff);
        }

        $("#tuxlink").unbind('click').click(function() { 
            const hackerClass = 'hacker';
            $('html, body, header, nav, table, pre, span, :not(.card-staff) > a, p, h1, h2, h3, h4, h5, h6').toggleClass(hackerClass);
            $('ul, img, pre').toggleClass(hackerClass);
            $('.toc').toggleClass(hackerClass);
            $('.content .highlighter-rouge').toggleClass(hackerClass);
            $('.large-centered.columns').toggleClass(hackerClass);
            $('.pad').toggleClass(hackerClass);
            $('a').toggleClass(hackerClass);
            $('tbody tr:nth-child(2n+1)').toggleClass(hackerClass);
            $("#tuxlink img").toggleClass(hackerClass);

            const val = window.localStorage.getItem(hackerKey);
            if (val === hackerOff) {
                window.localStorage.setItem(hackerKey, hackerOn);
            } else {
                window.localStorage.setItem(hackerKey, hackerOff);
            }
            return false; 
        }); 
        $("#tuxlink").click();
        const stored = window.localStorage.getItem(hackerKey);
        if (stored === hackerOn) {
            console.log("Hello!")
            $("#tuxlink").click();
        } else {
            console.log("Noo");
        }

        return false; 
    }); 
    } 
    ); 
    </script>

<script src="/js/analytics.js"></script>

<footer class="">

<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

</body>
</html>
